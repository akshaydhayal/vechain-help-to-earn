I am sharing you code file from learn to earn app that is working like ours on testnet:

components/WalletConnection.jsx:
import React, { useEffect, useState } from 'react';
import { useDAppKitWallet, useDAppKitWalletModal, useConnex } from '@vechain/vechain-kit';

function WalletConnection({ onAccountChange }) {
  const { account, disconnect, connect, setSource } = useDAppKitWallet();
  const { open: openModal } = useDAppKitWalletModal();
  const connex = useConnex();
  const [balance, setBalance] = useState(null);

  useEffect(() => {
    if (account) {
      onAccountChange(account);
      // Persist wallet connection
      localStorage.setItem('vechain_wallet_connected', 'true');
      localStorage.setItem('vechain_wallet_address', account);
      
      // Fetch balance
      fetchBalance(account);
    } else {
      onAccountChange(null);
      localStorage.removeItem('vechain_wallet_connected');
      localStorage.removeItem('vechain_wallet_address');
      setBalance(null);
    }
  }, [account, onAccountChange]);
  
  const fetchBalance = async (address) => {
    if (!connex) return;
    
    try {
      const acc = await connex.thor.account(address).get();
      const balanceInWei = acc.balance;
      const balanceInVET = (parseInt(balanceInWei, 16) / 1e18).toFixed(2);
      setBalance(balanceInVET);
    } catch (error) {
      console.error('Error fetching balance:', error);
    }
  };

  // Auto-reconnect is handled by VeChain Kit's persistence

  const handleConnect = () => {
    // Open the DApp Kit wallet modal
    openModal();
  };

  const handleDisconnect = async () => {
    try {
      await disconnect();
    } catch (error) {
      console.error('Failed to disconnect wallet:', error);
    }
  };

  const formatAddress = (address) => {
    if (!address) return '';
    return `${address.slice(0, 6)}...${address.slice(-4)}`;
  };

  if (account) {
    return (
      <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
        <div className="connected-address">
          Connected: {formatAddress(account)}
          {balance !== null && (
            <div style={{ fontSize: '0.8rem', color: '#666', marginTop: '0.25rem' }}>
              Balance: {balance} VET
            </div>
          )}
          {connex && (
            <div style={{ fontSize: '0.8rem', color: '#28a745', marginTop: '0.25rem' }}>
              ‚úì Connex Ready
            </div>
          )}
        </div>
        <button className="btn btn-secondary" onClick={handleDisconnect}>
          Disconnect
        </button>
      </div>
    );
  }

  return (
    <button 
      className="btn" 
      onClick={handleConnect}
    >
      Connect Wallet
    </button>
  );
}

export default WalletConnection;

components/StudentRegistration.jsx:
import React, { useState, useMemo } from 'react';
import { useWallet, useSendTransaction, useTransactionModal } from '@vechain/vechain-kit';
import { ethers } from 'ethers';
import { CONTRACT_ADDRESS, CONTRACT_ABI } from '../config/contract';

function StudentRegistration({ account, onRegistrationSuccess, onRegistrationStatusChange }) {
  const { account: walletAccount } = useWallet();
  const { open: openTransactionModal } = useTransactionModal();
  
  const [isRegistering, setIsRegistering] = useState(false);
  const [registrationStatus, setRegistrationStatus] = useState(null);
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: ''
  });

  // Create transaction clauses using VeChain Kit pattern
  const transactionClauses = useMemo(() => {
    if (!formData.firstName.trim() || !formData.lastName.trim()) {
      return [];
    }

    // Find the addStudent function ABI
    const addStudentABI = CONTRACT_ABI.find(fn => fn.name === 'addStudent');
    if (!addStudentABI) {
      return [];
    }

    try {
      // Create contract interface for proper ABI encoding
      const iface = new ethers.Interface(CONTRACT_ABI);
      
      // Encode the function call with parameters
      const firstName = formData.firstName.trim();
      const lastName = formData.lastName.trim();
      const data = iface.encodeFunctionData('addStudent', [firstName, lastName]);

      return [{
        to: CONTRACT_ADDRESS,
        value: '1000000000000000000', // 1 VET in wei
        data: data,
        comment: `Register as Learn2Earn Student: ${firstName} ${lastName}`,
        abi: addStudentABI,
      }];
    } catch (error) {
      console.error('Error encoding transaction data:', error);
      return [];
    }
  }, [formData.firstName, formData.lastName]);

  // Get the current account address
  const currentAccount = walletAccount?.address || account;
  
  // Setup the transaction hook with enhanced debugging
  const {
    sendTransaction,
    isTransactionPending,
    status,
    error: transactionError,
    txReceipt,
  } = useSendTransaction({
    signerAccountAddress: currentAccount ?? '',
    onTxConfirmed: () => {
      
      setRegistrationStatus({
        type: 'success',
        message: 'Successfully registered as a student! You can now submit proofs.'
      });
      if (onRegistrationSuccess) {
        setTimeout(onRegistrationSuccess, 2000);
      }
    },
    onTxFailedOrCancelled: (error) => {
      
      // Check if this is a "already registered" error
      if (error?.reason === 'Transaction reverted with: You are already registered.') {
        setRegistrationStatus({
          type: 'info',
          message: '‚úÖ You are already registered as a student! You can submit proofs.'
        });
        if (onRegistrationSuccess) {
          setTimeout(onRegistrationSuccess, 1000);
        }
        return;
      }
      
      setRegistrationStatus({
        type: 'error',
        message: error?.reason || error?.message || 'Transaction failed or was cancelled.'
      });
    }
  });

  // Monitor transaction status changes (minimal logging)
  React.useEffect(() => {
    // Handle case where we have a receipt but status is error due to revert
    if (txReceipt && status === 'error' && transactionError?.reason === 'Transaction reverted with: You are already registered.') {
      setRegistrationStatus({
        type: 'info',
        message: '‚úÖ You are already registered as a student! You can submit proofs.'
      });
      if (onRegistrationSuccess) {
        setTimeout(onRegistrationSuccess, 1000);
      }
    }
  }, [status, isTransactionPending, transactionError, txReceipt, onRegistrationSuccess]);

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleRegister = async (e) => {
    e.preventDefault();
    
    if (!formData.firstName.trim() || !formData.lastName.trim()) {
      setRegistrationStatus({
        type: 'error',
        message: 'Please fill in both first name and last name'
      });
      return;
    }

    if (!currentAccount || currentAccount === '*') {
      setRegistrationStatus({ type: 'error', message: 'Please connect your wallet first' });
      return;
    }

    if (transactionClauses.length === 0) {
      setRegistrationStatus({ type: 'error', message: 'Transaction not ready. Please check form data.' });
      return;
    }

    setIsRegistering(true);
    setRegistrationStatus({
      type: 'info',
      message: 'üîÑ Preparing registration transaction...'
    });

    try {

      // Open the transaction modal (VeChain Kit UI)
      openTransactionModal();
      
      // Send the transaction using VeChain Kit (ignore gas estimation errors - they don't prevent success)
      await sendTransaction(transactionClauses);
      
      setRegistrationStatus({
        type: 'info',
        message: '‚è≥ Transaction submitted, waiting for confirmation...'
      });

      
      // The success/failure handling is done in the useSendTransaction callbacks
      
    } catch (error) {
      setRegistrationStatus({
        type: 'error',
        message: error.message || 'Transaction failed. Please try again.'
      });
    } finally {
      setIsRegistering(false);
    }
  };



  return (
    <div className="card">
      <h2>Student Registration</h2>
      <p>Register as a student to participate in the Learn2Earn program. Registration fee: 1 VET</p>
      
      <form onSubmit={handleRegister}>
        <div className="form-group">
          <label htmlFor="firstName">First Name</label>
          <input
            type="text"
            id="firstName"
            name="firstName"
            value={formData.firstName}
            onChange={handleChange}
            placeholder="Enter your first name"
            disabled={isRegistering}
            required
          />
        </div>

        <div className="form-group">
          <label htmlFor="lastName">Last Name</label>
          <input
            type="text"
            id="lastName"
            name="lastName"
            value={formData.lastName}
            onChange={handleChange}
            placeholder="Enter your last name"
            disabled={isRegistering}
            required
          />
        </div>

        <button 
          type="submit" 
          className="btn" 
          disabled={isRegistering || !currentAccount}
        >
          {isRegistering ? (
            <>
              <span className="loading"></span> Registering...
            </>
          ) : (
            'Register (1 VET)'
          )}
        </button>


        {registrationStatus && (
          <div className={`status-message ${registrationStatus.type}`}>
            {registrationStatus.message}
            
            {/* Show explorer link if we have a receipt */}
            {txReceipt && (
              <div style={{ marginTop: '0.5rem' }}>
                <button
                  type="button"
                  onClick={() => window.open(`https://explore-testnet.vechain.org/transactions/${txReceipt.meta?.txID}`, '_blank')}
                  style={{
                    background: 'transparent',
                    border: '1px solid currentColor',
                    padding: '0.25rem 0.5rem',
                    borderRadius: '4px',
                    cursor: 'pointer',
                    fontSize: '0.9rem'
                  }}
                >
                  View on Explorer
                </button>
              </div>
            )}
            
            {/* Show manual check option if waiting for confirmation */}
            {registrationStatus.type === 'info' && registrationStatus.message.includes('waiting for confirmation') && (
              <div style={{ marginTop: '0.5rem' }}>
                <button
                  type="button"
                  onClick={() => {
                    setRegistrationStatus({
                      type: 'success',
                      message: 'Registration completed! If transaction succeeded, you can now submit proofs.'
                    });
                    if (onRegistrationSuccess) {
                      setTimeout(onRegistrationSuccess, 1000);
                    }
                  }}
                  style={{
                    background: '#28a745',
                    color: 'white',
                    border: 'none',
                    padding: '0.5rem 1rem',
                    borderRadius: '4px',
                    cursor: 'pointer',
                    fontSize: '0.9rem',
                    marginLeft: '0.5rem'
                  }}
                >
                  ‚úì Mark as Complete
                </button>
                <div style={{ fontSize: '0.8rem', color: '#666', marginTop: '0.25rem' }}>
                  Click if your transaction was confirmed in VeWorld
                </div>
              </div>
            )}
          </div>
        )}
      </form>
    </div>
  );
}

export default StudentRegistration;

components/ProofSubmission.jsx file:
import React, { useState } from 'react';
import { submitProof } from '../services/api';

function ProofSubmissionForm({ account, onSubmissionSuccess, disabled }) {
  const [formData, setFormData] = useState({
    name: '',
    proofLink: ''
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState(false);

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
    setError('');
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!formData.name.trim() || !formData.proofLink.trim()) {
      setError('Please fill in all fields');
      return;
    }

    if (!formData.proofLink.startsWith('http://') && !formData.proofLink.startsWith('https://')) {
      setError('Please enter a valid URL for the proof link');
      return;
    }

    setIsSubmitting(true);
    setError('');

    try {
      await submitProof({
        walletAddress: account.toLowerCase(),
        name: formData.name,
        proofLink: formData.proofLink
      });
      
      setSuccess(true);
      setFormData({ name: '', proofLink: '' });
      onSubmissionSuccess();
      
      setTimeout(() => setSuccess(false), 5000);
    } catch (err) {
      setError(err.message || 'Failed to submit proof. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div className="form-group">
        <label htmlFor="name">Name</label>
        <input
          type="text"
          id="name"
          name="name"
          value={formData.name}
          onChange={handleChange}
          placeholder="Enter your name"
          disabled={disabled || isSubmitting}
        />
      </div>

      <div className="form-group">
        <label htmlFor="proofLink">Proof Link</label>
        <input
          type="url"
          id="proofLink"
          name="proofLink"
          value={formData.proofLink}
          onChange={handleChange}
          placeholder="https://github.com/yourrepo or screenshot link"
          disabled={disabled || isSubmitting}
        />
      </div>

      <button 
        type="submit" 
        className="btn" 
        disabled={disabled || isSubmitting || !account}
      >
        {isSubmitting ? (
          <>
            <span className="loading"></span> Submitting...
          </>
        ) : (
          'Submit Proof'
        )}
      </button>

      {error && (
        <div className="status-message error">
          {error}
        </div>
      )}

      {success && (
        <div className="status-message success">
          Proof submitted successfully! Waiting for moderator approval.
        </div>
      )}

      {disabled && (
        <div className="status-message info">
          You have already submitted your proof. Please wait for approval.
        </div>
      )}
    </form>
  );
}

export default ProofSubmissionForm;

components/ClaimRewards.jsx file:
import React, { useState, useEffect } from 'react';
import { CONTRACT_ADDRESS, CONTRACT_ABI } from '../config/contract';

function ClaimReward({ account }) {
  const [isClaiming, setIsClaiming] = useState(false);
  const [claimStatus, setClaimStatus] = useState(null);
  const [txId, setTxId] = useState(null);
  const [isRegistered, setIsRegistered] = useState(true); // Default to true since this component only shows for registered users
  const [isAlreadyGraded, setIsAlreadyGraded] = useState(false);
  const [isAlreadyRewarded, setIsAlreadyRewarded] = useState(false);

  useEffect(() => {
    checkStudentStatus();
  }, [account]);

  const checkStudentStatus = async () => {
    if (!account) return;

    // Since this component uses the backend API, we don't need to check blockchain status
    // The backend handles the smart contract interactions
    console.log('ClaimReward component ready for account:', account);
  };

  const handleClaimReward = async () => {
    if (!account) {
      setClaimStatus({ type: 'error', message: 'Wallet not connected' });
      return;
    }

    setIsClaiming(true);
    setClaimStatus(null);

    try {
      // Call the backend API to claim the reward
      const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001/api';
      const response = await fetch(`${API_BASE_URL}/submissions/${account.toLowerCase()}/claim`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        }
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || 'Failed to claim reward');
      }

      setTxId(data.txId);
      setClaimStatus({
        type: 'success',
        message: data.txId === 'pending' ? 
          'Reward claim recorded! Note: Smart contract integration is pending - this is currently a demo.' :
          'Reward claim submitted! Transaction is being processed.'
      });

      // Refresh the student status after a delay
      setTimeout(() => {
        checkStudentStatus();
      }, 3000);

    } catch (error) {
      console.error('Error claiming reward:', error);
      setClaimStatus({
        type: 'error',
        message: error.message || 'Failed to claim reward. Please try again.'
      });
    } finally {
      setIsClaiming(false);
    }
  };

  // Transaction monitoring is handled by the backend
  // No need for client-side transaction monitoring since the backend handles the claim

  const openExplorer = () => {
    if (txId && txId !== 'pending') {
      window.open(`https://explore-testnet.vechain.org/transactions/${txId}`, '_blank');
    }
  };

  if (!isRegistered) {
    return (
      <div className="reward-section">
        <h3>Student Registration Required</h3>
        <p>You need to register as a student first before you can claim rewards.</p>
        <div className="status-message info">
          Please register as a student by paying the 1 VET registration fee.
        </div>
      </div>
    );
  }

  if (isAlreadyRewarded) {
    return (
      <div className="reward-section">
        <h3>Reward Already Claimed</h3>
        <p>You have already claimed your B3TR token reward for this submission.</p>
        <div className="status-message success">
          Your B3TR tokens have been distributed to your wallet.
        </div>
      </div>
    );
  }

  return (
    <div className="reward-section">
      <h3>Congratulations! Your submission has been approved</h3>
      <p>You can now claim your B3TR token reward</p>
      
      {isAlreadyGraded && (
        <div className="status-message info">
          Your submission has already been graded. You can claim your reward below.
        </div>
      )}
      
      <button
        className="btn btn-success"
        onClick={handleClaimReward}
        disabled={isClaiming}
      >
        {isClaiming ? (
          <>
            <span className="loading"></span> Claiming Reward...
          </>
        ) : (
          'Claim Reward'
        )}
      </button>

      {claimStatus && (
        <div className={`status-message ${claimStatus.type}`}>
          {claimStatus.message}
          {txId && claimStatus.type === 'success' && (
            <div style={{ marginTop: '0.5rem' }}>
              <button
                onClick={openExplorer}
                style={{
                  background: 'transparent',
                  border: '1px solid currentColor',
                  padding: '0.25rem 0.5rem',
                  borderRadius: '4px',
                  cursor: 'pointer',
                  fontSize: '0.9rem'
                }}
              >
                View on Explorer
              </button>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

export default ClaimReward;

App.jsx file:
import React, { useState, useEffect } from 'react';
import { VeChainKitProvider, TransactionModalProvider } from '@vechain/vechain-kit';
import WalletConnection from './components/WalletConnection';
import StudentRegistration from './components/StudentRegistration';
import ProofSubmissionForm from './components/ProofSubmissionForm';
import ClaimReward from './components/ClaimReward';
import { checkSubmissionStatus } from './services/api';
import { CONTRACT_ADDRESS } from './config/contract';

function AppContent() {
  const [account, setAccount] = useState(null);
  const [submissionStatus, setSubmissionStatus] = useState(null);
  const [isApproved, setIsApproved] = useState(false);
  const [isClaimed, setIsClaimed] = useState(false);
  const [isRegistered, setIsRegistered] = useState(false);

  useEffect(() => {
    if (account) {
      checkStatus();
    }
  }, [account]);

  const checkStatus = async () => {
    try {
      // Check backend API status
      const status = await checkSubmissionStatus(account);
      setSubmissionStatus(status);
      
      // If we have backend data, use it to set all states
      if (status) {
        const approved = status.approved === true;
        const claimed = status.claimed === true;
        
        setIsApproved(approved);
        setIsClaimed(claimed);
        
        // If they have submitted, approved, or claimed - they must be registered
        if (status.submitted || status.approved || status.claimed) {
          setIsRegistered(true);
        }
      }
    } catch (error) {
      console.error('Error checking status:', error);
    }
  };

  const handleSubmissionSuccess = () => {
    setSubmissionStatus({ submitted: true, approved: false });
    setTimeout(checkStatus, 2000);
  };

  const handleRegistrationSuccess = () => {
    setIsRegistered(true);
    setTimeout(() => {
      checkStatus();
    }, 2000);
  };

  return (
    <div className="container">
      <header className="header">
        <h1>Learn2Earn</h1>
        <p>Complete learning tasks and earn B3TR tokens</p>
      </header>

      <div className="wallet-section">
        <WalletConnection onAccountChange={setAccount} />
      </div>

      {account && (
        <>
          {!isRegistered && (
            <StudentRegistration 
              account={account} 
              onRegistrationSuccess={handleRegistrationSuccess}
              onRegistrationStatusChange={setIsRegistered}
            />
          )}

          {isRegistered && (
            <>
              {/* Show final claimed state */}
              {(isClaimed || submissionStatus?.claimed) ? (
                <div className="card">
                  <div className="reward-section">
                    <h3>‚úÖ Reward Successfully Claimed!</h3>
                    <p>Your B3TR tokens have been distributed to your wallet.</p>
                    <div className="status-message success">
                      Claimed on: {new Date(submissionStatus?.claimedAt).toLocaleDateString()}
                    </div>
                    {submissionStatus?.transactionHash && (
                      <div style={{ marginTop: '1rem' }}>
                        <a
                          href={`https://explore-testnet.vechain.org/transactions/${submissionStatus.transactionHash}`}
                          target="_blank"
                          rel="noopener noreferrer"
                          style={{
                            display: 'inline-block',
                            padding: '0.5rem 1rem',
                            backgroundColor: '#007bff',
                            color: 'white',
                            textDecoration: 'none',
                            borderRadius: '4px',
                            fontSize: '0.9rem'
                          }}
                        >
                          View Transaction on Explorer
                        </a>
                      </div>
                    )}
                  </div>
                </div>
              ) : (isApproved || submissionStatus?.approved) ? (
                /* Show claim reward section */
                <div className="card">
                  <ClaimReward account={account} />
                </div>
              ) : (
                /* Show submission form and status */
                <div className="card">
                  <h2>Submit Your Proof of Learning</h2>
                  <ProofSubmissionForm 
                    account={account}
                    onSubmissionSuccess={handleSubmissionSuccess}
                    disabled={submissionStatus?.submitted}
                  />
                  {submissionStatus?.submitted && !submissionStatus?.approved && (
                    <div className="status-message info">
                      Your submission is under review. Please check back later.
                    </div>
                  )}
                </div>
              )}
            </>
          )}
        </>
      )}

      {!account && (
        <div className="card">
          <p style={{ textAlign: 'center', color: '#666' }}>
            Please connect your VeWorld wallet to get started
          </p>
        </div>
      )}
    </div>
  );
}

function App() {
  return (
    <VeChainKitProvider
      network={{
        type: 'test',
        nodeUrl: 'https://testnet.vechain.org/',
        genesisId: '0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127'
      }}
      dappKit={{
        nodeUrl: 'https://testnet.vechain.org/',
        genesis: 'test',
        walletConnectOptions: {
          projectId: 'YOUR_WALLET_CONNECT_PROJECT_ID', 
          metadata: {
            name: 'Learn2Earn',
            description: 'VeChain Education Platform',
            url: window.location.origin,
            icons: [`${window.location.origin}/logo.png`],
          },
        },
        usePersistence: true,
        useFirstDetectedSource: false,
        allowedWallets: ['veworld', 'sync2', 'wallet-connect']
      }}
      loginMethods={['vechain', 'wallet']}
    >
      <TransactionModalProvider>
        <AppContent />
      </TransactionModalProvider>
    </VeChainKitProvider>
  );
}

export default App;

config/Contract.js file
export const CONTRACT_ADDRESS = '0xa56903cf66bacca8fb5911eb759a8566bda978ac';

export const CONTRACT_ABI = [
  {
    name: 'addStudent',
    type: 'function',
    inputs: [
      { name: '_name', type: 'string' },
      { name: '_familyName', type: 'string' }
    ],
    outputs: [],
    stateMutability: 'payable'
  },
  {
    name: 'submitProof',
    type: 'function',
    inputs: [
      { name: 'proof', type: 'string' }
    ],
    outputs: [],
    stateMutability: 'nonpayable'
  },
  {
    name: 'gradeSubmission',
    type: 'function',
    inputs: [
      { name: 'studentAddress', type: 'address' },
      { name: 'approved', type: 'bool' }
    ],
    outputs: [],
    stateMutability: 'nonpayable'
  },
  {
    name: 'isGraded',
    type: 'function',
    inputs: [
      { name: 'studentAddress', type: 'address' }
    ],
    outputs: [
      { name: '', type: 'bool' }
    ],
    stateMutability: 'view'
  },
  {
    name: 'isRewarded',
    type: 'function',
    inputs: [
      { name: 'studentAddress', type: 'address' }
    ],
    outputs: [
      { name: '', type: 'bool' }
    ],
    stateMutability: 'view'
  },
  {
    name: 'getSubmission',
    type: 'function',
    inputs: [
      { name: 'studentAddress', type: 'address' }
    ],
    outputs: [
      { name: '', type: 'string' }
    ],
    stateMutability: 'view'
  }
];

src/services/api.js:
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001/api';

export const submitProof = async (data) => {
  try {
    const response = await axios.post(`${API_BASE_URL}/submissions`, data);
    return response.data;
  } catch (error) {
    throw new Error(error.response?.data?.message || 'Failed to submit proof');
  }
};

export const checkSubmissionStatus = async (walletAddress) => {
  try {
    // Normalize address to lowercase for consistency
    const normalizedAddress = walletAddress.toLowerCase();
    const response = await axios.get(`${API_BASE_URL}/submissions/${normalizedAddress}`);
    return response.data;
  } catch (error) {
    if (error.response?.status === 404) {
      return null;
    }
    throw new Error(error.response?.data?.message || 'Failed to check submission status');
  }
};

export const getApprovedSubmissions = async () => {
  try {
    const response = await axios.get(`${API_BASE_URL}/submissions/approved`);
    return response.data;
  } catch (error) {
    throw new Error(error.response?.data?.message || 'Failed to fetch approved submissions');
  }
};

and now backend code:
backend/server.js file:
import express from 'express';
import cors from 'cors';
import sqlite3 from 'sqlite3';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import dotenv from 'dotenv';
import { gradeSubmissionOnChain } from './contractService.js';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3001;

app.use(cors());
app.use(express.json());

const db = new sqlite3.Database(join(__dirname, 'submissions.db'));

db.run(`
  CREATE TABLE IF NOT EXISTS submissions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    wallet_address TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    proof_link TEXT NOT NULL,
    submitted_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    approved BOOLEAN DEFAULT 0,
    approved_at DATETIME,
    moderator_notes TEXT,
    claimed BOOLEAN DEFAULT 0,
    claimed_at DATETIME,
    transaction_hash TEXT
  )
`);

// Add the new columns if they don't exist (migration)
db.run(`ALTER TABLE submissions ADD COLUMN claimed BOOLEAN DEFAULT 0`, (err) => {
  if (err && !err.message.includes('duplicate column name')) {
    console.error('Error adding claimed column:', err.message);
  }
});

db.run(`ALTER TABLE submissions ADD COLUMN claimed_at DATETIME`, (err) => {
  if (err && !err.message.includes('duplicate column name')) {
    console.error('Error adding claimed_at column:', err.message);
  }
});

db.run(`ALTER TABLE submissions ADD COLUMN transaction_hash TEXT`, (err) => {
  if (err && !err.message.includes('duplicate column name')) {
    console.error('Error adding transaction_hash column:', err.message);
  }
});

app.post('/api/submissions', async (req, res) => {
  const { walletAddress, name, proofLink } = req.body;

  if (!walletAddress || !name || !proofLink) {
    return res.status(400).json({ 
      message: 'Missing required fields: walletAddress, name, and proofLink are required' 
    });
  }

  try {
    const existingSubmission = await new Promise((resolve, reject) => {
      db.get(
        'SELECT * FROM submissions WHERE wallet_address = ?',
        [walletAddress],
        (err, row) => {
          if (err) reject(err);
          else resolve(row);
        }
      );
    });

    if (existingSubmission) {
      return res.status(400).json({ 
        message: 'You have already submitted a proof' 
      });
    }

    await new Promise((resolve, reject) => {
      db.run(
        'INSERT INTO submissions (wallet_address, name, proof_link) VALUES (?, ?, ?)',
        [walletAddress, name, proofLink],
        function(err) {
          if (err) reject(err);
          else resolve(this.lastID);
        }
      );
    });

    res.status(201).json({ 
      message: 'Submission received successfully',
      walletAddress 
    });
  } catch (error) {
    console.error('Error saving submission:', error);
    res.status(500).json({ 
      message: 'Failed to save submission' 
    });
  }
});

app.get('/api/submissions/:walletAddress', async (req, res) => {
  const { walletAddress } = req.params;

  try {
    const submission = await new Promise((resolve, reject) => {
      db.get(
        'SELECT * FROM submissions WHERE wallet_address = ?',
        [walletAddress],
        (err, row) => {
          if (err) reject(err);
          else resolve(row);
        }
      );
    });

    if (!submission) {
      return res.status(404).json({ 
        message: 'No submission found' 
      });
    }

    res.json({
      submitted: true,
      approved: submission.approved === 1,
      claimed: submission.claimed === 1,
      submittedAt: submission.submitted_at,
      approvedAt: submission.approved_at,
      claimedAt: submission.claimed_at,
      transactionHash: submission.transaction_hash,
      name: submission.name,
      proofLink: submission.proof_link
    });
  } catch (error) {
    console.error('Error fetching submission:', error);
    res.status(500).json({ 
      message: 'Failed to fetch submission' 
    });
  }
});

app.get('/api/submissions', async (req, res) => {
  try {
    const submissions = await new Promise((resolve, reject) => {
      db.all(
        'SELECT * FROM submissions ORDER BY submitted_at DESC',
        (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        }
      );
    });

    res.json(submissions.map(sub => ({
      id: sub.id,
      walletAddress: sub.wallet_address,
      name: sub.name,
      proofLink: sub.proof_link,
      submitted: true,
      approved: sub.approved === 1,
      submittedAt: sub.submitted_at,
      approvedAt: sub.approved_at,
      moderatorNotes: sub.moderator_notes
    })));
  } catch (error) {
    console.error('Error fetching submissions:', error);
    res.status(500).json({ 
      message: 'Failed to fetch submissions' 
    });
  }
});

app.put('/api/submissions/:walletAddress/approve', async (req, res) => {
  const { walletAddress } = req.params;
  const { approved, moderatorNotes } = req.body;
  
  const moderatorKey = req.headers['x-moderator-key'];
  
  if (moderatorKey !== process.env.MODERATOR_KEY) {
    return res.status(401).json({ 
      message: 'Unauthorized' 
    });
  }

  try {
    await new Promise((resolve, reject) => {
      db.run(
        `UPDATE submissions 
         SET approved = ?, approved_at = ?, moderator_notes = ?
         WHERE wallet_address = ?`,
        [approved ? 1 : 0, new Date().toISOString(), moderatorNotes || null, walletAddress],
        function(err) {
          if (err) reject(err);
          else resolve(this.changes);
        }
      );
    });

    res.json({ 
      message: 'Submission updated successfully',
      approved 
    });
  } catch (error) {
    console.error('Error updating submission:', error);
    res.status(500).json({ 
      message: 'Failed to update submission' 
    });
  }
});

app.get('/api/submissions/approved', async (req, res) => {
  try {
    const submissions = await new Promise((resolve, reject) => {
      db.all(
        'SELECT wallet_address, name FROM submissions WHERE approved = 1',
        (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        }
      );
    });

    res.json(submissions);
  } catch (error) {
    console.error('Error fetching approved submissions:', error);
    res.status(500).json({ 
      message: 'Failed to fetch approved submissions' 
    });
  }
});

// NEW: Endpoint for students to claim rewards (calls smart contract as registrar)
app.post('/api/submissions/:walletAddress/claim', async (req, res) => {
  const { walletAddress } = req.params;
  
  try {
    // Check if submission is approved in database
    const submission = await new Promise((resolve, reject) => {
      db.get(
        'SELECT * FROM submissions WHERE wallet_address = ? AND approved = 1',
        [walletAddress.toLowerCase()],
        (err, row) => {
          if (err) reject(err);
          else resolve(row);
        }
      );
    });

    if (!submission) {
      return res.status(404).json({ 
        message: 'No approved submission found for this wallet address' 
      });
    }

    // Check if already claimed
    if (submission.claimed) {
      return res.status(400).json({ 
        message: 'Reward has already been claimed' 
      });
    }

    console.log(`Processing reward claim for ${walletAddress}`);

    // Call the smart contract gradeSubmission function
    const contractResult = await gradeSubmissionOnChain(walletAddress, true);

    if (contractResult.success) {
      // Update database with transaction hash
      await new Promise((resolve, reject) => {
        db.run(
          'UPDATE submissions SET claimed = 1, claimed_at = ?, transaction_hash = ? WHERE wallet_address = ?',
          [new Date().toISOString(), contractResult.txId, walletAddress.toLowerCase()],
          function(err) {
            if (err) reject(err);
            else resolve(this.changes);
          }
        );
      });

      res.json({ 
        message: 'Reward successfully claimed! B3TR tokens have been distributed.',
        txId: contractResult.txId,
        success: true
      });
    } else {
      res.status(500).json({ 
        message: `Smart contract transaction failed: ${contractResult.error}`,
        error: contractResult.error
      });
    }

  } catch (error) {
    console.error('Error processing reward claim:', error);
    res.status(500).json({ 
      message: 'Failed to process reward claim' 
    });
  }
});

app.listen(PORT, () => {
  console.log(`Backend server running on http://localhost:${PORT}`);
});

backend/contractService.js code:
import { ThorClient } from '@vechain/sdk-network';
import pkg from '@vechain/sdk-core';
const { Address, Hex, TransactionHandler, unitsUtils, secp256k1 } = pkg;
import dotenv from 'dotenv';

dotenv.config();

// Contract configuration
const CONTRACT_ADDRESS = '0xa56903cf66bacca8fb5911eb759a8566bda978ac';
const NETWORK_URL = 'https://testnet.vechain.org/';
const REGISTRAR_PRIVATE_KEY = process.env.VECHAIN_PRIVATE_KEY;

// Contract ABI for gradeSubmission function
const GRADE_SUBMISSION_ABI = {
  name: 'gradeSubmission',
  type: 'function',
  inputs: [
    { name: 'studentAddress', type: 'address' },
    { name: 'approved', type: 'bool' }
  ],
  outputs: [],
  stateMutability: 'nonpayable'
};

// Initialize VeChain SDK
const thor = ThorClient.fromUrl(NETWORK_URL);

export async function gradeSubmissionOnChain(studentAddress, approved) {
  try {
    console.log(`Calling gradeSubmission for ${studentAddress}, approved: ${approved}`);

    // Create private key buffer
    const privateKeyBuffer = Hex.of(REGISTRAR_PRIVATE_KEY).bytes;
    
    // Derive the registrar address
    const registrarAddress = Address.ofPublicKey(secp256k1.derivePublicKey(privateKeyBuffer));
    console.log('Registrar address:', registrarAddress.toString());

    // Get the latest block
    const bestBlock = await thor.blocks.getBestBlockCompressed();
    
    // Create transaction clause
    const clause = {
      to: CONTRACT_ADDRESS,
      value: '0x0',
      data: thor.contracts.encodeFunctionInput(GRADE_SUBMISSION_ABI, [studentAddress, approved])
    };

    console.log('Transaction clause:', clause);

    // Build transaction
    const txBody = {
      chainTag: bestBlock.id.slice(-2),
      blockRef: bestBlock.id.slice(0, 18),
      expiration: 32,
      clauses: [clause],
      gasPriceCoef: 0,
      gas: 200000,
      dependsOn: null,
      nonce: Date.now().toString()
    };

    console.log('Transaction body:', txBody);

    // Sign and send transaction
    const signedTx = TransactionHandler.sign(txBody, privateKeyBuffer);
    const txId = await thor.transactions.sendTransaction(signedTx);
    
    console.log('Transaction sent:', txId);
    
    // Wait for transaction receipt
    const receipt = await waitForTransaction(txId);
    
    if (receipt && !receipt.reverted) {
      console.log('Transaction successful:', txId);
      return {
        success: true,
        txId: txId,
        receipt: receipt
      };
    } else {
      console.error('Transaction reverted:', receipt);
      return {
        success: false,
        txId: txId,
        error: 'Transaction was reverted'
      };
    }

  } catch (error) {
    console.error('Error calling gradeSubmission:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

async function waitForTransaction(txId, timeout = 30000) {
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeout) {
    try {
      const receipt = await thor.transactions.getTransactionReceipt(txId);
      if (receipt) {
        return receipt;
      }
    } catch (error) {
      // Transaction not found yet, continue waiting
    }
    
    // Wait 2 seconds before checking again
    await new Promise(resolve => setTimeout(resolve, 2000));
  }
  
  throw new Error('Transaction timeout');
}

and this is contract code:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// Interface for VeBetterDAO X2EarnRewardsPool
interface IX2EarnRewardsPool {
    function distributeReward(
        bytes32 appId,
        uint256 amount,
        address receiver,
        string memory proof
    ) external;
    
    function availableFunds(bytes32 appId) external view returns (uint256);
}

contract Learn2Earn {

    // The address of the registrar (contract creator)
    address private registrar;

    // The name of the university
    string public institute;
    
    // VeBetterDAO integration
    IX2EarnRewardsPool public x2EarnRewardsPoolContract;
    bytes32 public appId;
    uint256 public rewardAmount = 10 * 10**18; // 10 B3TR tokens per approved submission

    // Structure to store student information
    struct Student {
        address wallet;         // Student's wallet address
        string name;            // First name
        string familyName;      // Last name
        bool registered;        // True if student is registered
        bool graduated;         // True if student has graduated
        bytes32 certificate;    // Certificate hash (created when student graduates)
    }

    // Mapping from wallet address to student data
    mapping(address => Student) public students;

    // NEW: Mapping to store proof submissions
    mapping(address => string) public submissions;
    
    // NEW: Mapping to track if submission has been graded
    mapping(address => bool) public graded;
    
    // NEW: Mapping to track if student has been rewarded
    mapping(address => bool) public rewarded;

    // Event triggered when a certificate is issued
    event CertificateIssued(string institute, bytes32 certificateHash, address student);
    
    // NEW: Event triggered when a proof is submitted
    event SubmissionReceived(address indexed user, string proof);
    
    // NEW: Event triggered when a submission is graded and approved
    event SubmissionGraded(address indexed user, bool approved);
    
    // NEW: Event triggered when rewards are distributed
    event RewardDistributed(address indexed user, uint256 amount);

    // Set the university name, registrar, and VeBetterDAO details when contract is deployed
    constructor(
        string memory _institute,
        address _x2EarnRewardsPoolContract,
        bytes32 _appId
    ) {
        registrar = msg.sender;
        institute = _institute;
        x2EarnRewardsPoolContract = IX2EarnRewardsPool(_x2EarnRewardsPoolContract);
        appId = _appId;
    }

    // Function for students to register by paying 1 VET
    function addStudent(string memory _name, string memory _familyName) public payable {
        require(msg.value == 1 ether, "You must pay 1 VET to register.");

        // Make sure the student isn't already registered
        require(!students[msg.sender].registered, "You are already registered.");

        // Create a new student record
        students[msg.sender] = Student({
            wallet: msg.sender,
            name: _name,
            familyName: _familyName,
            registered: true,
            graduated: false,
            certificate: 0
        });
    }

    function _checkStudent(address studentAddress) view private returns (bool){
        Student storage student = students[studentAddress];
        require(student.registered, "This person is not a registered student.");
        return true;
    }

    // NEW: Function for students to submit proof of learning completion
    function submitProof(string memory proof) public {
        require(students[msg.sender].registered, "You must be a registered student to submit proof.");
        require(!students[msg.sender].graduated, "You have already graduated.");
        require(bytes(proof).length > 0, "Proof cannot be empty.");
        
        // Store the submission
        submissions[msg.sender] = proof;
        
        // Emit event
        emit SubmissionReceived(msg.sender, proof);
    }

    // NEW: Function for registrar to grade submissions and trigger rewards
    function gradeSubmission(address studentAddress, bool approved) public {
        require(msg.sender == registrar, "Only the registrar can grade submissions.");
        require(students[studentAddress].registered, "This person is not a registered student.");
        require(bytes(submissions[studentAddress]).length > 0, "No submission found for this student.");
        require(!graded[studentAddress], "This submission has already been graded.");
        
        // Mark as graded
        graded[studentAddress] = true;
        
        // Emit grading event
        emit SubmissionGraded(studentAddress, approved);
        
        if (approved && !rewarded[studentAddress]) {
            // Distribute VeBetterDAO rewards
            _distributeReward(studentAddress);
        }
    }
    
    // NEW: Internal function to distribute VeBetterDAO rewards
    function _distributeReward(address studentAddress) private {
        require(rewardAmount > 0, "Reward amount must be greater than 0");
        require(
            rewardAmount <= x2EarnRewardsPoolContract.availableFunds(appId),
            "Insufficient funds in rewards pool"
        );
        
        // Mark as rewarded to prevent double rewards
        rewarded[studentAddress] = true;
        
        // Create proof string with submission info
        string memory proof = string(abi.encodePacked(
            '{"type":"education","submission":"',
            submissions[studentAddress],
            '","institute":"',
            institute,
            '"}'
        ));
        
        // Call VeBetterDAO to distribute rewards
        x2EarnRewardsPoolContract.distributeReward(
            appId,
            rewardAmount,
            studentAddress,
            proof
        );
        
        emit RewardDistributed(studentAddress, rewardAmount);
    }

    // Registrar can mark a student as graduated (after grading)
    function issueCertificate(address studentAddress) public {
        require(msg.sender == registrar, "Only the registrar can issue certificates.");

        if (_checkStudent(studentAddress)){
            Student storage student = students[studentAddress];
            require(!student.graduated, "This student has already graduated.");
            
            // NEW: Ensure submission was graded and approved before issuing certificate
            require(graded[studentAddress], "Student submission must be graded first.");
            
            // Create a certificate and mark as graduated
            student.certificate = keccak256(abi.encodePacked(block.timestamp, student.wallet));
            student.graduated = true;

            // Emit event
            emit CertificateIssued(institute, student.certificate, student.wallet);
        }
    }

    // Check if a student has graduated
    function isGraduated(address studentAddress) public view returns (bool) {
        return students[studentAddress].graduated;
    }
    
    // NEW: Get a student's submission
    function getSubmission(address studentAddress) public view returns (string memory) {
        return submissions[studentAddress];
    }
    
    // NEW: Check if a submission has been graded
    function isGraded(address studentAddress) public view returns (bool) {
        return graded[studentAddress];
    }
    
    // NEW: Check if a student has been rewarded
    function isRewarded(address studentAddress) public view returns (bool) {
        return rewarded[studentAddress];
    }
    
    // NEW: Get available funds in the rewards pool
    function getAvailableFunds() public view returns (uint256) {
        return x2EarnRewardsPoolContract.availableFunds(appId);
    }
    
    // NEW: Registrar can set reward amount
    function setRewardAmount(uint256 _amount) public {
        require(msg.sender == registrar, "Only the registrar can set reward amount.");
        require(_amount > 0, "Amount must be greater than 0.");
        rewardAmount = _amount;
    }
    
    // NEW: Registrar can update app ID
    function updateAppId(bytes32 _appId) public {
        require(msg.sender == registrar, "Only the registrar can update app ID.");
        appId = _appId;
    }
    
    // NEW: Registrar can withdraw collected VET from student registrations
    function withdrawBalance() public {
        require(msg.sender == registrar, "Only the registrar can withdraw.");
        uint256 balance = address(this).balance;
        require(balance > 0, "No balance to withdraw.");
        (bool success, ) = payable(registrar).call{value: balance}("");
        require(success, "Transfer failed.");
    }
}

and these .env.example for repo:
# Backend Configuration
PORT=3001
MODERATOR_KEY=your-secret-moderator-key-here

# Frontend Configuration
REACT_APP_API_URL=http://localhost:3001/api

# VeChain Contract Configuration
REACT_APP_CONTRACT_ADDRESS=0x0000000000000000000000000000000000000000
REACT_APP_NETWORK=testnet

# WalletConnect Project ID
REACT_APP_WALLET_CONNECT_PROJECT_ID=your-wallet-connect-project-id

# Deployment Configuration
VECHAIN_PRIVATE_KEY=your-private-key-here

# VeBetterDAO Testnet Addresses (DO NOT MODIFY)
X2EARN_REWARDS_POOL=0x5F8f86B8D0Fa93cdaE20936d150175dF0205fB38
X2EARN_APPS=0xcB23Eb1bBD5c07553795b9538b1061D0f4ABA153
B3TR_TOKEN=0xbf64cf86894Ee0877C4e7d03936e35Ee8D8b864F
B3TR_FAUCET=0x5e9c1F0f52aC6b5004122059053b00017EAfB561

# Your VeBetterDAO App ID (obtain after registration)
VEBETTERDAO_APP_ID=0x0000000000000000000000000000000000000000000000000000000000000001

now based on this check what we aremissing and not doinn that connects our deployed cntract to smart contracta nd we can preform on chain transaction on vechain tes5ent. I wanwt the contarct t wrk with frontend through veworld wallet. you do anyting for that. just deep dive and fix thisasap now.