Send Transactions
The useSendTransaction hook is mandatory if you use social login in your app, since it handles the social login transactions (that needs to be prepared and broadcasted differently from normal transactions). If you are not interested in social login features then you can avoid using useSendTransaction and useSignMessage and use the signer exported by the kit following the SDK guides for creating transactions or signing messages.

This hook will take care of checking your connection type and handle the transaction submission between privy, cross-app and wallet connections.

When implementing VeChain Kit it is mandatory to use this hook to send transaction.

Use our pre built TransactionModal or TransactionToast components to show your users the progress and outcome of the transaction, or build your own UX and UI.

Copy
'use client';

import {
    useWallet,
    useSendTransaction,
    useTransactionModal,
    TransactionModal,
    getConfig
} from '@vechain/vechain-kit';
import { IB3TR__factory } from '@vechain/vechain-kit/contracts';
import { humanAddress } from '@vechain/vechain-kit/utils';
import { useMemo, useCallback } from 'react';

export function TransactionExamples() {
    const { account } = useWallet();
    const b3trMainnetAddress = getConfig("main").b3trContractAddress;
    
    const clauses = useMemo(() => {
        const B3TRInterface = IB3TR__factory.createInterface();

        const clausesArray: any[] = [];
        clausesArray.push({
            to: b3trMainnetAddress,
            value: '0x0',
            data: B3TRInterface.encodeFunctionData('transfer', [
                "0x0, // receiver address
                '0', // 0 B3TR (in wei)
            ]),
            comment: `This is a dummy transaction to test the transaction modal. Confirm to transfer ${0} B3TR to ${humanAddress("Ox0")}`,
            abi: B3TRInterface.getFunction('transfer'),
        });

        return clausesArray;
    }, [connectedWallet?.address]);

    const {
        sendTransaction,
        status,
        txReceipt,
        resetStatus,
        isTransactionPending,
        error,
    } = useSendTransaction({
        signerAccountAddress: account?.address ?? '',
    });

    const {
        open: openTransactionModal,
        close: closeTransactionModal,
        isOpen: isTransactionModalOpen,
    } = useTransactionModal();

    // This is the function triggering the transaction and opening the modal
    const handleTransaction = useCallback(async () => {
        openTransactionModal();
        await sendTransaction(clauses);
    }, [sendTransaction, clauses, openTransactionModal]);
    
    const handleTryAgain = useCallback(async () => {
        resetStatus();
        await sendTransaction(clauses);
    }, [sendTransaction, clauses, resetStatus]);

    return (
        <>
            <button
                onClick={handleTransactionWithModal}
                isLoading={isTransactionPending}
                isDisabled={isTransactionPending}
            >
                Send B3TR
            </button>

            <TransactionModal
                isOpen={isTransactionModalOpen}
                onClose={closeTransactionModal}
                status={status}
                txReceipt={txReceipt}
                txError={error}
                onTryAgain={handleTryAgain}
                uiConfig={{
                    title: 'Test Transaction',
                    description: `This is a dummy transaction to test the transaction modal. Confirm to transfer ${0} B3TR to ${
                        account?.address
                    }`,
                    showShareOnSocials: true,
                    showExplorerButton: true,
                    isClosable: true,
                }}
            />
        </>
    );
}
You can build clauses with some of our available build functions, with our SDK or  with connex.

If you want to interact directly with the user's smart account read the Smart Accounts section.

Important

Ensuring data is pre-fetched before initiating a transaction is crucial to avoid browser pop-up blocking for users using social login, which can adversely affect user experience.

Copy
// ✅ Good: Pre-fetch data
const { data } = useQuery(['someData'], fetchSomeData);
const sendTx = () => sendTransaction(data);

// ⛔ Bad: Fetching data during the transaction
const sendTx = async () => {
  const data = await fetchSomeData();
  return sendTransaction(data);
};
🔧 Custom Gas Configuration (optional)
When sending transactions using VechainKit, you can fine-tune the gas settings by using two optional fields: suggestedMaxGas and gasPadding. These options give you greater control over the gas behavior of your transaction.

suggestedMaxGas
The suggestedMaxGas parameter allows you to explicitly define the maximum amount of gas to be used for the transaction. When this field is set, it will override the internal gas estimation logic and also ignore any gasPadding value.

Expected format: an integer representing gas units (e.g., 40000000 for 40 million gas).

Use this option when you want full control and know in advance the maximum gas your transaction should consume.

Example:

Copy
useSendTransaction({
  ..., //other config
  suggestedMaxGas: 40000000, // Sets the gas limit directly
});
gasPadding
The gasPadding option allows you to add a safety buffer on top of the estimated gas. This can be useful to prevent underestimations for complex transactions.

Expected format: a number between 0 and 1, representing a percentage increase (e.g., 0.1 adds 10%).

Only applied if suggestedMaxGas is not set.

Example:

Copy
useSendTransaction({
  ..., //other config
  gasPadding: 0.1, // Adds 10% buffer to estimated gas
});
Summary
Option
Type
Applies Gas Estimation
Applies Padding
Overwrites Estimation
suggestedMaxGas

Integer

❌

❌

✅

gasPadding

Float (0–1)

✅

✅

❌

Use suggestedMaxGas when you want to define the gas cap directly, and gasPadding when you prefer to work with auto-estimation but want a bit of headroom.


and this is docs for signin tx messages:
Sign Messages
Sign Message
Sign a string, eg "Hello VeChain", with the useSignMessage() hook.

Copy
'use client';

import { ReactElement, useCallback } from 'react';
import {
    useSignMessage,
} from '@vechain/vechain-kit';

export function SigningExample(): ReactElement {
    const {
        signMessage,
        isSigningPending: isMessageSignPending,
        signature: messageSignature,
    } = useSignMessage();

   const handleSignMessage = useCallback(async () => {
        try {
            const signature = await signMessage('Hello VeChain!');
            toast({
                title: 'Message signed!',
                description: `Signature: ${signature.slice(0, 20)}...`,
                status: 'success',
                duration: 1000,
                isClosable: true,
            });
        } catch (error) {
            toast({
                title: 'Signing failed',
                description:
                    error instanceof Error ? error.message : String(error),
                status: 'error',
                duration: 1000,
                isClosable: true,
            });
        }
    }, [signMessage, toast]);

    return (
        <>
            <button
                onClick={handleSignTypedData}
                isLoading={isTypedDataSignPending}
            >
                Sign Typed Data
            </button>
            {typedDataSignature && (
                <h4>
                    {typedDataSignature}
                </h4>
            )}
        </>
    );
}
Sign Typed Data (EIP712)
Use the useSignTypedData() hook to sign structured data. 

Copy
'use client';

import { ReactElement, useCallback } from 'react';
import {
    useWallet,
    useSignTypedData,
} from '@vechain/vechain-kit';

// Example EIP-712 typed data
const exampleTypedData = {
    domain: {
        name: 'VeChain Example',
        version: '1',
        chainId: 1,
    },
    types: {
        Person: [
            { name: 'name', type: 'string' },
            { name: 'wallet', type: 'address' },
        ],
    },
    message: {
        name: 'Alice',
        wallet: '0x0000000000000000000000000000000000000000',
    },
    primaryType: 'Person',
};

export function SigningTypedDataExample(): ReactElement {
    const {
        signTypedData,
        isSigningPending: isTypedDataSignPending,
        signature: typedDataSignature,
    } = useSignTypedData();
    
    const { account } = useWallet()

    const handleSignTypedData = useCallback(async () => {
        try {
            const signature = await signTypedData(exampleTypedData, {
                signer: account?.address
            });
            alert({
                title: 'Typed data signed!',
                description: `Signature: ${signature.slice(0, 20)}...`,
                status: 'success',
                duration: 1000,
                isClosable: true,
            });
        } catch (error) {
            alert({
                title: 'Signing failed',
                description:
                    error instanceof Error ? error.message : String(error),
                status: 'error',
                duration: 1000,
                isClosable: true,
            });
        }
    }, [signTypedData, toast, account]);

    return (
        <>
            <button
                onClick={handleSignTypedData}
                isLoading={isTypedDataSignPending}
            >
                Sign Typed Data
            </button>
            {typedDataSignature && (
                <h4>
                    {typedDataSignature}
                </h4>
            )}
        </>
    );
}
Certificate Signing
To authenticate users in your backend (BE) and issue them a JWT (JSON Web Token), you may need to check that the connected user actually holds the private keys of that wallet (assuring he is not pretending to be someone else). 

The recommended approach is to use signTypedData to have the user sign a piece of structured data, ensuring the signed payload is unique for each authentication request.

When using Privy the user owns a smart account (which is a smart contract), and he cannot directly sign a message with the smart account but needs to do it with his Embedded Wallet (the wallet created and secured by Privy). This means that when you verify identities of users connected with social login you will need to check that the address that signed the message is actually the owner of the smart account.

Example usage
SignatureWrapperProvider.tsx
Create a provider that will handle the signature verification.

Copy
import { useSignatureVerification } from "../hooks/useSignatureVerification";
import { Modal, ModalOverlay, ModalContent, VStack, Text, Spinner, Button } from "@chakra-ui/react";
import { useTranslation } from "react-i18next";
import { ReactNode, useEffect } from "react";
import { useWallet } from "@vechain/vechain-kit";
import { clearSignature, usePostUser } from "@/hooks";

type Props = {
  children: ReactNode;
};

export const SignatureVerificationWrapper = ({ children }: Props) => {
  const { hasVerified, isVerifying, signature, verifySignature, value } = useSignatureVerification();
  const { account } = useWallet();
  const { t } = useTranslation();

  const { mutate: postUser } = usePostUser();

  useEffect(() => {
    if (account?.address && !signature) {
      verifySignature();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [account?.address, signature]);

  useEffect(() => {
    // If user signed the signature we call our backend endpoint
    if (signature && value.user !== "" && value.timestamp !== "" && account?.address) {
      // When you want to execute the mutation:
      postUser({
        address: account.address,
        value: value,
        signature: signature,
      });
    }
  }, [signature, value, account?.address, postUser]);

  // if user disconnects we clear the signature
  useEffect(() => {
    if (!account) {
      clearSignature();
    }
  }, [account]);

  // Only show the modal if we have an account connected AND haven't verified yet AND are not in the process of verifying
  const showModal = !!account?.address && (!hasVerified || !signature);

  return (
    <>
      {children}
      <Modal isOpen={showModal} onClose={() => {}} isCentered closeOnOverlayClick={false}>
        <ModalOverlay />
        <ModalContent p={6}>
          <VStack spacing={4}>
            {isVerifying ? (
              <>
                <Spinner size="xl" color="primary.500" />
                <Text textAlign="center" fontSize="lg">
                  {t("Please sign the message to verify your wallet ownership")}
                </Text>
              </>
            ) : (
              <>
                <Text textAlign="center" fontSize="lg">
                  {t("Signature verification is mandatory to proceed. Please try again.")}
                </Text>
                <Button onClick={verifySignature} colorScheme="secondary">
                  {t("Try Again")}
                </Button>
              </>
            )}
          </VStack>
        </ModalContent>
      </Modal>
    </>
  );
};

main.tsx:
Wrap the app with our new provider

Copy
import React from "react";
import ReactDOM from "react-dom/client";
import { VeChainKitProviderWrapper } from "./components/VeChainKitProviderWrapper.tsx";
import { ChakraProvider, ColorModeScript } from "@chakra-ui/react";
import { lightTheme } from "./theme";
import { RouterProvider } from "react-router-dom";
import { router } from "./router";
import { AppProvider } from "./components/AppProvider.tsx";
import { SignatureVerificationWrapper } from "./components/SignatureVerificationWrapper.tsx";

(async () => {
  ReactDOM.createRoot(document.getElementById("root")!).render(
    <React.StrictMode>
      <ChakraProvider theme={lightTheme}>
        <ColorModeScript initialColorMode="light" />
        <VeChainKitProviderWrapper>
          <SignatureVerificationWrapper>
              <AppProvider>
                <RouterProvider router={router} />
              </AppProvider>
          </SignatureVerificationWrapper>
        </VeChainKitProviderWrapper>
      </ChakraProvider>
    </React.StrictMode>,
  );
})();

useSignatureVerification.ts:
Handle the signature within a custom hook

Copy
import { useWallet, useSignTypedData } from "@vechain/vechain-kit";
import { useState, useCallback } from "react";
import { ethers } from "ethers";

// EIP-712 typed data structure
const domain = {
  name: "MyAppName",
  version: "1",
};

const types = {
  Authentication: [
    { name: "user", type: "address" },
    { name: "timestamp", type: "string" },
  ],
};

export type SignatureVerificationValue = {
  user: string;
  timestamp: string;
};

export const useSignatureVerification = () => {
  const { account } = useWallet();
  const { signTypedData } = useSignTypedData();
  const [isVerifying, setIsVerifying] = useState(false);
  const [value, setValue] = useState<SignatureVerificationValue>({
    user: "",
    timestamp: "",
  });

  const signature = localStorage.getItem(`login_signature`);

  const verifySignature = useCallback(async () => {
    if (!account?.address || isVerifying) return;

    setValue({
      user: account.address,
      timestamp: new Date().toISOString(),
    });

    const existingSignature = localStorage.getItem(`login_signature`);
    if (existingSignature) return;

    setIsVerifying(true);
    try {
      const signature = await signTypedData({
        domain,
        types,
        message: value,
        primaryType: "Authentication",
      }, {
        signer: account?.address
      });

      const isValid = ethers.verifyTypedData(domain, types, value, signature);

      if (!isValid) {
        throw new Error("Signature verification failed");
      }

      localStorage.setItem(`login_signature`, signature);
    } catch (error) {
      console.error("Signature verification failed:", error);
    } finally {
      setIsVerifying(false);
    }
  }, [account?.address, isVerifying, signTypedData, value]);

  const hasVerified = account?.address ? !!localStorage.getItem(`login_signature`) : false;

  return { hasVerified, isVerifying, signature, verifySignature, value };
};

Backend Validation

On your backend validate the signature as follows:

Copy
import {ethers} from "ethers";

static async verifySignature(signature: string, value: { user: string , timestamp: string }): Promise<string> {
    const domain = {
        name: "My App Name",
        version: "1",
    };

    const types = {
        Authentication: [
            {name: "user", type: "address"},
            {name: "timestamp", type: "string"},
        ],
    };

    return ethers.verifyTypedData(domain, types, value, signature);
}

const signerAddress = await verifySignature(
      signature,
      value
    );
    
if (signerAddress.toLowerCase() != address.toLowerCase()) {
    return {
        statusCode: 403,
        body: JSON.stringify({
        error: "Invalid signature",
        }),
    };
}

You should deprecate this:

Copy
import { useConnex } from '@vechain/vechain-kit';

export default function Home(): ReactElement {
    const connex = useConnex();

    const handleSignWithConnex = () => {
        connex.vendor.sign(    
            'cert',
            {
                purpose: 'identification',
                payload: {
                    type: 'text',
                    content: 'Please sign this message to connect your wallet.',
                },
            }
        ).request();
    }
    
    return <button onClick={handleSignWithConnex}> Sign </button>
}

Best Practices
Essential patterns for optimal performance, type safety, and maintainability

Type Safety
Copy
// ✅ Good: Proper typing
const args: [string, bigint, boolean] = [address, amount, isEnabled];
const contractAddress = config.contractAddress as `0x${string}`;
const method = 'balanceOf' as const;

// ✅ Use contract factories
import { VOT3__factory } from '@vechain/vechain-kit/contracts';
const abi = VOT3__factory.abi;

// Avoid: Manual ABI definitions
const functionAbi = contractAbi.find((e) => e.name === "delegates");
Query Optimization
Copy
// ✅ Good: Conditional enablement
return useCallClause({
  abi,
  address: contractAddress,
  method: 'getData',
  args: [userAddress],
  queryOptions: {
    enabled: !!contractAddress && !!userAddress && isConnected,
  },
});

// ✅ Good: Configure caching
queryOptions: {
  staleTime: 30000,        // 30 seconds for price data
  refetchInterval: 60000,  // Refetch every minute
}
Data Transformation
Copy
// ✅ Good: Transform in select
return useCallClause({
  abi: VOT3__factory.abi,
  address: contractAddress,
  method: 'convertedB3trOf' as const,
  args: [address ?? ''],
  queryOptions: {
    enabled: !!address,
    select: (data) => ({
      balance: ethers.formatEther(data[0]),
      formatted: humanNumber(ethers.formatEther(data[0])),
    }),
  },
});

// Avoid: Transform in component
const transformedData = useMemo(() => ({
  balance: data?.[0]?.toString(),
}), [data]); // Causes re-renders
Error Handling
Copy
// ✅ Good: Comprehensive error handling
if (error) {
  if (error.message.includes('reverted')) {
    return <div>Contract call failed. Check parameters.</div>;
  }
  if (error.message.includes('network')) {
    return <div>Network error. <button onClick={refetch}>Retry</button></div>;
  }
  return <div>Error: {error.message}</div>;
}

// ✅ Good: Retry logic
queryOptions: {
  retry: (failureCount, error) => {
    if (error.message.includes('reverted')) return false;
    return failureCount < 3;
  },
  retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
}
Query Key Management
Copy
// ✅ Good: Use getCallClauseQueryKey (without args) 
export const getCurrentAllocationsRoundIdQueryKey = (
  address: string,
  networkType: NETWORK_TYPE
) =>
  getCallClauseQueryKey({
    abi: XAllocationVoting__factory.abi,
    address: getConfig(networkType).contractAddress as `0x${string}`,
    method: 'currentRoundId' as const,
  });
  
// ✅ Good: Use getCallClauseQueryKeyWithArgs
export const getTokenBalanceQueryKey = (
  address: string,
  networkType: NETWORK_TYPE
) =>
  getCallClauseQueryKeyWithArgs({
    abi: VOT3__factory.abi,
    address: getConfig(networkType).contractAddress as `0x${string}`,
    method: 'balanceOf' as const,
    args: [address],
  });

// ✅ Good: Query invalidation after transactions
const mutation = useBuildTransaction({
  clauseBuilder: buildClauses,
  onTxConfirmed: () => {
    queryClient.invalidateQueries({ queryKey: getTokenBalanceQueryKey(userAddress, networkType) });
  },
});
Performance Tips
Copy
// ✅ Good: Memoize expensive calculations
const queryKey = useMemo(() => 
  getTokenBalanceQueryKey(userAddress, tokenAddress),
  [userAddress, tokenAddress]
);

// ✅ Good: Batch multiple calls
const results = await executeMultipleClausesCall({
  thor,
  calls: addresses.map((address) => ({
    abi: ERC20__factory.abi,
    functionName: 'balanceOf',
    address: address as `0x${string}`,
    args: [userAddress],
  })),
});
Security
Copy
// ✅ Good: Input validation
if (!isAddress(recipient)) {
  throw new Error('Invalid recipient address');
}

const amountBN = BigInt(amount);
if (amountBN <= 0n) {
  throw new Error('Amount must be positive');
}

// ✅ Good: Safe BigInt handling
const formatTokenAmount = (amount: bigint, decimals: number): string => {
  try {
    return ethers.formatUnits(amount, decimals);
  } catch (error) {
    return '0';
  }
};
Single Contract Call Pattern
Copy
import { VOT3__factory } from '@vechain/vechain-kit/contracts';
import { useCallClause, getCallClauseQueryKeyWithArgs } from '@vechain/vechain-kit';

const abi = VOT3__factory.abi;
const method = 'convertedB3trOf' as const;

export const useTokenBalance = (address?: string) => {
  const { network } = useVeChainKitConfig();
  const contractAddress = getConfig(network.type).contractAddress as `0x${string}`;

  return useCallClause({
    abi,
    address: contractAddress,
    method,
    args: [address ?? ''],
    queryOptions: {
      enabled: !!address,
      select: (data) => ({
        balance: ethers.formatEther(data[0]),
        formatted: humanNumber(ethers.formatEther(data[0])),
      }),
    },
  });
};
Multiple Contract Calls Pattern
Copy
import { useQuery } from '@tanstack/react-query';
import { executeMultipleClausesCall } from '@vechain/vechain-kit';

export const useMultipleTokenData = (addresses: string[]) => {
  const thor = useThor();

  return useQuery({
    queryKey: ['MULTIPLE_TOKENS', addresses],
    queryFn: async () => {
      const results = await executeMultipleClausesCall({
        thor,
        calls: addresses.map((address) => ({
          abi: ERC20__factory.abi,
          functionName: 'balanceOf',
          address: address as `0x${string}`,
          args: [userAddress],
        })),
      });

      return addresses.map((address, index) => ({
        address,
        balance: ethers.formatEther(results[index][0]),
      }));
    },
    enabled: !!addresses.length,
  });
};
Transaction Building Pattern
Copy
import { useBuildTransaction, useWallet } from '@vechain/vechain-kit';

export const useTokenTransfer = () => {
  const { account } = useWallet();
  const thor = useThor();

  return useBuildTransaction({
    clauseBuilder: (recipient: string, amount: string) => {
      if (!account?.address) return [];

      const { clause } = thor.contracts
        .load(tokenAddress, ERC20__factory.abi)
        .clause.transfer(recipient, ethers.parseEther(amount));

      return [{
        ...clause,
        comment: `Transfer ${amount} tokens to ${recipient}`,
      }];
    },
    onTxConfirmed: () => {
      queryClient.invalidateQueries({ queryKey: ['TOKEN_BALANCE'] });
    },
  });
};
Multi-Clause Transactions
Copy
const useApproveAndSwap = () => {
  const { account } = useWallet();
  const thor = useThor();

  return useBuildTransaction({
    clauseBuilder: (tokenAddress: string, amount: string) => {
      if (!account?.address) return [];

      return [
        // Approve
        {
          ...thor.contracts
            .load(tokenAddress, ERC20__factory.abi)
            .clause.approve(swapAddress, ethers.parseEther(amount)).clause,
          comment: 'Approve token spending',
        },
        // Swap
        {
          ...thor.contracts
            .load(swapAddress, SwapContract__factory.abi)
            .clause.swap(tokenAddress, ethers.parseEther(amount)).clause,
          comment: 'Execute swap',
        },
      ];
    },
  });
};
Error Handling
Copy
const useContractCall = (address: string) => {
  return useCallClause({
    abi: ContractABI,
    address: address as `0x${string}`,
    method: 'getData',
    args: [],
    queryOptions: {
      enabled: !!address,
      retry: (failureCount, error) => {
        if (error.message.includes('reverted')) return false;
        return failureCount < 3;
      },
    },
  });
};


use anyhting if yiu need from above docs reltaed to signing:

















I am sharing you code file from learn to earn app that is working like ours on testnet:

components/WalletConnection.jsx:
import React, { useEffect, useState } from 'react';
import { useDAppKitWallet, useDAppKitWalletModal, useConnex } from '@vechain/vechain-kit';

function WalletConnection({ onAccountChange }) {
  const { account, disconnect, connect, setSource } = useDAppKitWallet();
  const { open: openModal } = useDAppKitWalletModal();
  const connex = useConnex();
  const [balance, setBalance] = useState(null);

  useEffect(() => {
    if (account) {
      onAccountChange(account);
      // Persist wallet connection
      localStorage.setItem('vechain_wallet_connected', 'true');
      localStorage.setItem('vechain_wallet_address', account);
      
      // Fetch balance
      fetchBalance(account);
    } else {
      onAccountChange(null);
      localStorage.removeItem('vechain_wallet_connected');
      localStorage.removeItem('vechain_wallet_address');
      setBalance(null);
    }
  }, [account, onAccountChange]);
  
  const fetchBalance = async (address) => {
    if (!connex) return;
    
    try {
      const acc = await connex.thor.account(address).get();
      const balanceInWei = acc.balance;
      const balanceInVET = (parseInt(balanceInWei, 16) / 1e18).toFixed(2);
      setBalance(balanceInVET);
    } catch (error) {
      console.error('Error fetching balance:', error);
    }
  };

  // Auto-reconnect is handled by VeChain Kit's persistence

  const handleConnect = () => {
    // Open the DApp Kit wallet modal
    openModal();
  };

  const handleDisconnect = async () => {
    try {
      await disconnect();
    } catch (error) {
      console.error('Failed to disconnect wallet:', error);
    }
  };

  const formatAddress = (address) => {
    if (!address) return '';
    return `${address.slice(0, 6)}...${address.slice(-4)}`;
  };

  if (account) {
    return (
      <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
        <div className="connected-address">
          Connected: {formatAddress(account)}
          {balance !== null && (
            <div style={{ fontSize: '0.8rem', color: '#666', marginTop: '0.25rem' }}>
              Balance: {balance} VET
            </div>
          )}
          {connex && (
            <div style={{ fontSize: '0.8rem', color: '#28a745', marginTop: '0.25rem' }}>
              ✓ Connex Ready
            </div>
          )}
        </div>
        <button className="btn btn-secondary" onClick={handleDisconnect}>
          Disconnect
        </button>
      </div>
    );
  }

  return (
    <button 
      className="btn" 
      onClick={handleConnect}
    >
      Connect Wallet
    </button>
  );
}

export default WalletConnection;

components/StudentRegistration.jsx:
import React, { useState, useMemo } from 'react';
import { useWallet, useSendTransaction, useTransactionModal } from '@vechain/vechain-kit';
import { ethers } from 'ethers';
import { CONTRACT_ADDRESS, CONTRACT_ABI } from '../config/contract';

function StudentRegistration({ account, onRegistrationSuccess, onRegistrationStatusChange }) {
  const { account: walletAccount } = useWallet();
  const { open: openTransactionModal } = useTransactionModal();
  
  const [isRegistering, setIsRegistering] = useState(false);
  const [registrationStatus, setRegistrationStatus] = useState(null);
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: ''
  });

  // Create transaction clauses using VeChain Kit pattern
  const transactionClauses = useMemo(() => {
    if (!formData.firstName.trim() || !formData.lastName.trim()) {
      return [];
    }

    // Find the addStudent function ABI
    const addStudentABI = CONTRACT_ABI.find(fn => fn.name === 'addStudent');
    if (!addStudentABI) {
      return [];
    }

    try {
      // Create contract interface for proper ABI encoding
      const iface = new ethers.Interface(CONTRACT_ABI);
      
      // Encode the function call with parameters
      const firstName = formData.firstName.trim();
      const lastName = formData.lastName.trim();
      const data = iface.encodeFunctionData('addStudent', [firstName, lastName]);

      return [{
        to: CONTRACT_ADDRESS,
        value: '1000000000000000000', // 1 VET in wei
        data: data,
        comment: `Register as Learn2Earn Student: ${firstName} ${lastName}`,
        abi: addStudentABI,
      }];
    } catch (error) {
      console.error('Error encoding transaction data:', error);
      return [];
    }
  }, [formData.firstName, formData.lastName]);

  // Get the current account address
  const currentAccount = walletAccount?.address || account;
  
  // Setup the transaction hook with enhanced debugging
  const {
    sendTransaction,
    isTransactionPending,
    status,
    error: transactionError,
    txReceipt,
  } = useSendTransaction({
    signerAccountAddress: currentAccount ?? '',
    onTxConfirmed: () => {
      
      setRegistrationStatus({
        type: 'success',
        message: 'Successfully registered as a student! You can now submit proofs.'
      });
      if (onRegistrationSuccess) {
        setTimeout(onRegistrationSuccess, 2000);
      }
    },
    onTxFailedOrCancelled: (error) => {
      
      // Check if this is a "already registered" error
      if (error?.reason === 'Transaction reverted with: You are already registered.') {
        setRegistrationStatus({
          type: 'info',
          message: '✅ You are already registered as a student! You can submit proofs.'
        });
        if (onRegistrationSuccess) {
          setTimeout(onRegistrationSuccess, 1000);
        }
        return;
      }
      
      setRegistrationStatus({
        type: 'error',
        message: error?.reason || error?.message || 'Transaction failed or was cancelled.'
      });
    }
  });

  // Monitor transaction status changes (minimal logging)
  React.useEffect(() => {
    // Handle case where we have a receipt but status is error due to revert
    if (txReceipt && status === 'error' && transactionError?.reason === 'Transaction reverted with: You are already registered.') {
      setRegistrationStatus({
        type: 'info',
        message: '✅ You are already registered as a student! You can submit proofs.'
      });
      if (onRegistrationSuccess) {
        setTimeout(onRegistrationSuccess, 1000);
      }
    }
  }, [status, isTransactionPending, transactionError, txReceipt, onRegistrationSuccess]);

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleRegister = async (e) => {
    e.preventDefault();
    
    if (!formData.firstName.trim() || !formData.lastName.trim()) {
      setRegistrationStatus({
        type: 'error',
        message: 'Please fill in both first name and last name'
      });
      return;
    }

    if (!currentAccount || currentAccount === '*') {
      setRegistrationStatus({ type: 'error', message: 'Please connect your wallet first' });
      return;
    }

    if (transactionClauses.length === 0) {
      setRegistrationStatus({ type: 'error', message: 'Transaction not ready. Please check form data.' });
      return;
    }

    setIsRegistering(true);
    setRegistrationStatus({
      type: 'info',
      message: '🔄 Preparing registration transaction...'
    });

    try {

      // Open the transaction modal (VeChain Kit UI)
      openTransactionModal();
      
      // Send the transaction using VeChain Kit (ignore gas estimation errors - they don't prevent success)
      await sendTransaction(transactionClauses);
      
      setRegistrationStatus({
        type: 'info',
        message: '⏳ Transaction submitted, waiting for confirmation...'
      });

      
      // The success/failure handling is done in the useSendTransaction callbacks
      
    } catch (error) {
      setRegistrationStatus({
        type: 'error',
        message: error.message || 'Transaction failed. Please try again.'
      });
    } finally {
      setIsRegistering(false);
    }
  };



  return (
    <div className="card">
      <h2>Student Registration</h2>
      <p>Register as a student to participate in the Learn2Earn program. Registration fee: 1 VET</p>
      
      <form onSubmit={handleRegister}>
        <div className="form-group">
          <label htmlFor="firstName">First Name</label>
          <input
            type="text"
            id="firstName"
            name="firstName"
            value={formData.firstName}
            onChange={handleChange}
            placeholder="Enter your first name"
            disabled={isRegistering}
            required
          />
        </div>

        <div className="form-group">
          <label htmlFor="lastName">Last Name</label>
          <input
            type="text"
            id="lastName"
            name="lastName"
            value={formData.lastName}
            onChange={handleChange}
            placeholder="Enter your last name"
            disabled={isRegistering}
            required
          />
        </div>

        <button 
          type="submit" 
          className="btn" 
          disabled={isRegistering || !currentAccount}
        >
          {isRegistering ? (
            <>
              <span className="loading"></span> Registering...
            </>
          ) : (
            'Register (1 VET)'
          )}
        </button>


        {registrationStatus && (
          <div className={`status-message ${registrationStatus.type}`}>
            {registrationStatus.message}
            
            {/* Show explorer link if we have a receipt */}
            {txReceipt && (
              <div style={{ marginTop: '0.5rem' }}>
                <button
                  type="button"
                  onClick={() => window.open(`https://explore-testnet.vechain.org/transactions/${txReceipt.meta?.txID}`, '_blank')}
                  style={{
                    background: 'transparent',
                    border: '1px solid currentColor',
                    padding: '0.25rem 0.5rem',
                    borderRadius: '4px',
                    cursor: 'pointer',
                    fontSize: '0.9rem'
                  }}
                >
                  View on Explorer
                </button>
              </div>
            )}
            
            {/* Show manual check option if waiting for confirmation */}
            {registrationStatus.type === 'info' && registrationStatus.message.includes('waiting for confirmation') && (
              <div style={{ marginTop: '0.5rem' }}>
                <button
                  type="button"
                  onClick={() => {
                    setRegistrationStatus({
                      type: 'success',
                      message: 'Registration completed! If transaction succeeded, you can now submit proofs.'
                    });
                    if (onRegistrationSuccess) {
                      setTimeout(onRegistrationSuccess, 1000);
                    }
                  }}
                  style={{
                    background: '#28a745',
                    color: 'white',
                    border: 'none',
                    padding: '0.5rem 1rem',
                    borderRadius: '4px',
                    cursor: 'pointer',
                    fontSize: '0.9rem',
                    marginLeft: '0.5rem'
                  }}
                >
                  ✓ Mark as Complete
                </button>
                <div style={{ fontSize: '0.8rem', color: '#666', marginTop: '0.25rem' }}>
                  Click if your transaction was confirmed in VeWorld
                </div>
              </div>
            )}
          </div>
        )}
      </form>
    </div>
  );
}

export default StudentRegistration;

components/ProofSubmission.jsx file:
import React, { useState } from 'react';
import { submitProof } from '../services/api';

function ProofSubmissionForm({ account, onSubmissionSuccess, disabled }) {
  const [formData, setFormData] = useState({
    name: '',
    proofLink: ''
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState(false);

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
    setError('');
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!formData.name.trim() || !formData.proofLink.trim()) {
      setError('Please fill in all fields');
      return;
    }

    if (!formData.proofLink.startsWith('http://') && !formData.proofLink.startsWith('https://')) {
      setError('Please enter a valid URL for the proof link');
      return;
    }

    setIsSubmitting(true);
    setError('');

    try {
      await submitProof({
        walletAddress: account.toLowerCase(),
        name: formData.name,
        proofLink: formData.proofLink
      });
      
      setSuccess(true);
      setFormData({ name: '', proofLink: '' });
      onSubmissionSuccess();
      
      setTimeout(() => setSuccess(false), 5000);
    } catch (err) {
      setError(err.message || 'Failed to submit proof. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div className="form-group">
        <label htmlFor="name">Name</label>
        <input
          type="text"
          id="name"
          name="name"
          value={formData.name}
          onChange={handleChange}
          placeholder="Enter your name"
          disabled={disabled || isSubmitting}
        />
      </div>

      <div className="form-group">
        <label htmlFor="proofLink">Proof Link</label>
        <input
          type="url"
          id="proofLink"
          name="proofLink"
          value={formData.proofLink}
          onChange={handleChange}
          placeholder="https://github.com/yourrepo or screenshot link"
          disabled={disabled || isSubmitting}
        />
      </div>

      <button 
        type="submit" 
        className="btn" 
        disabled={disabled || isSubmitting || !account}
      >
        {isSubmitting ? (
          <>
            <span className="loading"></span> Submitting...
          </>
        ) : (
          'Submit Proof'
        )}
      </button>

      {error && (
        <div className="status-message error">
          {error}
        </div>
      )}

      {success && (
        <div className="status-message success">
          Proof submitted successfully! Waiting for moderator approval.
        </div>
      )}

      {disabled && (
        <div className="status-message info">
          You have already submitted your proof. Please wait for approval.
        </div>
      )}
    </form>
  );
}

export default ProofSubmissionForm;

components/ClaimRewards.jsx file:
import React, { useState, useEffect } from 'react';
import { CONTRACT_ADDRESS, CONTRACT_ABI } from '../config/contract';

function ClaimReward({ account }) {
  const [isClaiming, setIsClaiming] = useState(false);
  const [claimStatus, setClaimStatus] = useState(null);
  const [txId, setTxId] = useState(null);
  const [isRegistered, setIsRegistered] = useState(true); // Default to true since this component only shows for registered users
  const [isAlreadyGraded, setIsAlreadyGraded] = useState(false);
  const [isAlreadyRewarded, setIsAlreadyRewarded] = useState(false);

  useEffect(() => {
    checkStudentStatus();
  }, [account]);

  const checkStudentStatus = async () => {
    if (!account) return;

    // Since this component uses the backend API, we don't need to check blockchain status
    // The backend handles the smart contract interactions
    console.log('ClaimReward component ready for account:', account);
  };

  const handleClaimReward = async () => {
    if (!account) {
      setClaimStatus({ type: 'error', message: 'Wallet not connected' });
      return;
    }

    setIsClaiming(true);
    setClaimStatus(null);

    try {
      // Call the backend API to claim the reward
      const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001/api';
      const response = await fetch(`${API_BASE_URL}/submissions/${account.toLowerCase()}/claim`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        }
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || 'Failed to claim reward');
      }

      setTxId(data.txId);
      setClaimStatus({
        type: 'success',
        message: data.txId === 'pending' ? 
          'Reward claim recorded! Note: Smart contract integration is pending - this is currently a demo.' :
          'Reward claim submitted! Transaction is being processed.'
      });

      // Refresh the student status after a delay
      setTimeout(() => {
        checkStudentStatus();
      }, 3000);

    } catch (error) {
      console.error('Error claiming reward:', error);
      setClaimStatus({
        type: 'error',
        message: error.message || 'Failed to claim reward. Please try again.'
      });
    } finally {
      setIsClaiming(false);
    }
  };

  // Transaction monitoring is handled by the backend
  // No need for client-side transaction monitoring since the backend handles the claim

  const openExplorer = () => {
    if (txId && txId !== 'pending') {
      window.open(`https://explore-testnet.vechain.org/transactions/${txId}`, '_blank');
    }
  };

  if (!isRegistered) {
    return (
      <div className="reward-section">
        <h3>Student Registration Required</h3>
        <p>You need to register as a student first before you can claim rewards.</p>
        <div className="status-message info">
          Please register as a student by paying the 1 VET registration fee.
        </div>
      </div>
    );
  }

  if (isAlreadyRewarded) {
    return (
      <div className="reward-section">
        <h3>Reward Already Claimed</h3>
        <p>You have already claimed your B3TR token reward for this submission.</p>
        <div className="status-message success">
          Your B3TR tokens have been distributed to your wallet.
        </div>
      </div>
    );
  }

  return (
    <div className="reward-section">
      <h3>Congratulations! Your submission has been approved</h3>
      <p>You can now claim your B3TR token reward</p>
      
      {isAlreadyGraded && (
        <div className="status-message info">
          Your submission has already been graded. You can claim your reward below.
        </div>
      )}
      
      <button
        className="btn btn-success"
        onClick={handleClaimReward}
        disabled={isClaiming}
      >
        {isClaiming ? (
          <>
            <span className="loading"></span> Claiming Reward...
          </>
        ) : (
          'Claim Reward'
        )}
      </button>

      {claimStatus && (
        <div className={`status-message ${claimStatus.type}`}>
          {claimStatus.message}
          {txId && claimStatus.type === 'success' && (
            <div style={{ marginTop: '0.5rem' }}>
              <button
                onClick={openExplorer}
                style={{
                  background: 'transparent',
                  border: '1px solid currentColor',
                  padding: '0.25rem 0.5rem',
                  borderRadius: '4px',
                  cursor: 'pointer',
                  fontSize: '0.9rem'
                }}
              >
                View on Explorer
              </button>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

export default ClaimReward;

App.jsx file:
import React, { useState, useEffect } from 'react';
import { VeChainKitProvider, TransactionModalProvider } from '@vechain/vechain-kit';
import WalletConnection from './components/WalletConnection';
import StudentRegistration from './components/StudentRegistration';
import ProofSubmissionForm from './components/ProofSubmissionForm';
import ClaimReward from './components/ClaimReward';
import { checkSubmissionStatus } from './services/api';
import { CONTRACT_ADDRESS } from './config/contract';

function AppContent() {
  const [account, setAccount] = useState(null);
  const [submissionStatus, setSubmissionStatus] = useState(null);
  const [isApproved, setIsApproved] = useState(false);
  const [isClaimed, setIsClaimed] = useState(false);
  const [isRegistered, setIsRegistered] = useState(false);

  useEffect(() => {
    if (account) {
      checkStatus();
    }
  }, [account]);

  const checkStatus = async () => {
    try {
      // Check backend API status
      const status = await checkSubmissionStatus(account);
      setSubmissionStatus(status);
      
      // If we have backend data, use it to set all states
      if (status) {
        const approved = status.approved === true;
        const claimed = status.claimed === true;
        
        setIsApproved(approved);
        setIsClaimed(claimed);
        
        // If they have submitted, approved, or claimed - they must be registered
        if (status.submitted || status.approved || status.claimed) {
          setIsRegistered(true);
        }
      }
    } catch (error) {
      console.error('Error checking status:', error);
    }
  };

  const handleSubmissionSuccess = () => {
    setSubmissionStatus({ submitted: true, approved: false });
    setTimeout(checkStatus, 2000);
  };

  const handleRegistrationSuccess = () => {
    setIsRegistered(true);
    setTimeout(() => {
      checkStatus();
    }, 2000);
  };

  return (
    <div className="container">
      <header className="header">
        <h1>Learn2Earn</h1>
        <p>Complete learning tasks and earn B3TR tokens</p>
      </header>

      <div className="wallet-section">
        <WalletConnection onAccountChange={setAccount} />
      </div>

      {account && (
        <>
          {!isRegistered && (
            <StudentRegistration 
              account={account} 
              onRegistrationSuccess={handleRegistrationSuccess}
              onRegistrationStatusChange={setIsRegistered}
            />
          )}

          {isRegistered && (
            <>
              {/* Show final claimed state */}
              {(isClaimed || submissionStatus?.claimed) ? (
                <div className="card">
                  <div className="reward-section">
                    <h3>✅ Reward Successfully Claimed!</h3>
                    <p>Your B3TR tokens have been distributed to your wallet.</p>
                    <div className="status-message success">
                      Claimed on: {new Date(submissionStatus?.claimedAt).toLocaleDateString()}
                    </div>
                    {submissionStatus?.transactionHash && (
                      <div style={{ marginTop: '1rem' }}>
                        <a
                          href={`https://explore-testnet.vechain.org/transactions/${submissionStatus.transactionHash}`}
                          target="_blank"
                          rel="noopener noreferrer"
                          style={{
                            display: 'inline-block',
                            padding: '0.5rem 1rem',
                            backgroundColor: '#007bff',
                            color: 'white',
                            textDecoration: 'none',
                            borderRadius: '4px',
                            fontSize: '0.9rem'
                          }}
                        >
                          View Transaction on Explorer
                        </a>
                      </div>
                    )}
                  </div>
                </div>
              ) : (isApproved || submissionStatus?.approved) ? (
                /* Show claim reward section */
                <div className="card">
                  <ClaimReward account={account} />
                </div>
              ) : (
                /* Show submission form and status */
                <div className="card">
                  <h2>Submit Your Proof of Learning</h2>
                  <ProofSubmissionForm 
                    account={account}
                    onSubmissionSuccess={handleSubmissionSuccess}
                    disabled={submissionStatus?.submitted}
                  />
                  {submissionStatus?.submitted && !submissionStatus?.approved && (
                    <div className="status-message info">
                      Your submission is under review. Please check back later.
                    </div>
                  )}
                </div>
              )}
            </>
          )}
        </>
      )}

      {!account && (
        <div className="card">
          <p style={{ textAlign: 'center', color: '#666' }}>
            Please connect your VeWorld wallet to get started
          </p>
        </div>
      )}
    </div>
  );
}

function App() {
  return (
    <VeChainKitProvider
      network={{
        type: 'test',
        nodeUrl: 'https://testnet.vechain.org/',
        genesisId: '0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127'
      }}
      dappKit={{
        nodeUrl: 'https://testnet.vechain.org/',
        genesis: 'test',
        walletConnectOptions: {
          projectId: 'YOUR_WALLET_CONNECT_PROJECT_ID', 
          metadata: {
            name: 'Learn2Earn',
            description: 'VeChain Education Platform',
            url: window.location.origin,
            icons: [`${window.location.origin}/logo.png`],
          },
        },
        usePersistence: true,
        useFirstDetectedSource: false,
        allowedWallets: ['veworld', 'sync2', 'wallet-connect']
      }}
      loginMethods={['vechain', 'wallet']}
    >
      <TransactionModalProvider>
        <AppContent />
      </TransactionModalProvider>
    </VeChainKitProvider>
  );
}

export default App;

config/Contract.js file
export const CONTRACT_ADDRESS = '0xa56903cf66bacca8fb5911eb759a8566bda978ac';

export const CONTRACT_ABI = [
  {
    name: 'addStudent',
    type: 'function',
    inputs: [
      { name: '_name', type: 'string' },
      { name: '_familyName', type: 'string' }
    ],
    outputs: [],
    stateMutability: 'payable'
  },
  {
    name: 'submitProof',
    type: 'function',
    inputs: [
      { name: 'proof', type: 'string' }
    ],
    outputs: [],
    stateMutability: 'nonpayable'
  },
  {
    name: 'gradeSubmission',
    type: 'function',
    inputs: [
      { name: 'studentAddress', type: 'address' },
      { name: 'approved', type: 'bool' }
    ],
    outputs: [],
    stateMutability: 'nonpayable'
  },
  {
    name: 'isGraded',
    type: 'function',
    inputs: [
      { name: 'studentAddress', type: 'address' }
    ],
    outputs: [
      { name: '', type: 'bool' }
    ],
    stateMutability: 'view'
  },
  {
    name: 'isRewarded',
    type: 'function',
    inputs: [
      { name: 'studentAddress', type: 'address' }
    ],
    outputs: [
      { name: '', type: 'bool' }
    ],
    stateMutability: 'view'
  },
  {
    name: 'getSubmission',
    type: 'function',
    inputs: [
      { name: 'studentAddress', type: 'address' }
    ],
    outputs: [
      { name: '', type: 'string' }
    ],
    stateMutability: 'view'
  }
];

src/services/api.js:
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001/api';

export const submitProof = async (data) => {
  try {
    const response = await axios.post(`${API_BASE_URL}/submissions`, data);
    return response.data;
  } catch (error) {
    throw new Error(error.response?.data?.message || 'Failed to submit proof');
  }
};

export const checkSubmissionStatus = async (walletAddress) => {
  try {
    // Normalize address to lowercase for consistency
    const normalizedAddress = walletAddress.toLowerCase();
    const response = await axios.get(`${API_BASE_URL}/submissions/${normalizedAddress}`);
    return response.data;
  } catch (error) {
    if (error.response?.status === 404) {
      return null;
    }
    throw new Error(error.response?.data?.message || 'Failed to check submission status');
  }
};

export const getApprovedSubmissions = async () => {
  try {
    const response = await axios.get(`${API_BASE_URL}/submissions/approved`);
    return response.data;
  } catch (error) {
    throw new Error(error.response?.data?.message || 'Failed to fetch approved submissions');
  }
};

and now backend code:
backend/server.js file:
import express from 'express';
import cors from 'cors';
import sqlite3 from 'sqlite3';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import dotenv from 'dotenv';
import { gradeSubmissionOnChain } from './contractService.js';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3001;

app.use(cors());
app.use(express.json());

const db = new sqlite3.Database(join(__dirname, 'submissions.db'));

db.run(`
  CREATE TABLE IF NOT EXISTS submissions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    wallet_address TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    proof_link TEXT NOT NULL,
    submitted_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    approved BOOLEAN DEFAULT 0,
    approved_at DATETIME,
    moderator_notes TEXT,
    claimed BOOLEAN DEFAULT 0,
    claimed_at DATETIME,
    transaction_hash TEXT
  )
`);

// Add the new columns if they don't exist (migration)
db.run(`ALTER TABLE submissions ADD COLUMN claimed BOOLEAN DEFAULT 0`, (err) => {
  if (err && !err.message.includes('duplicate column name')) {
    console.error('Error adding claimed column:', err.message);
  }
});

db.run(`ALTER TABLE submissions ADD COLUMN claimed_at DATETIME`, (err) => {
  if (err && !err.message.includes('duplicate column name')) {
    console.error('Error adding claimed_at column:', err.message);
  }
});

db.run(`ALTER TABLE submissions ADD COLUMN transaction_hash TEXT`, (err) => {
  if (err && !err.message.includes('duplicate column name')) {
    console.error('Error adding transaction_hash column:', err.message);
  }
});

app.post('/api/submissions', async (req, res) => {
  const { walletAddress, name, proofLink } = req.body;

  if (!walletAddress || !name || !proofLink) {
    return res.status(400).json({ 
      message: 'Missing required fields: walletAddress, name, and proofLink are required' 
    });
  }

  try {
    const existingSubmission = await new Promise((resolve, reject) => {
      db.get(
        'SELECT * FROM submissions WHERE wallet_address = ?',
        [walletAddress],
        (err, row) => {
          if (err) reject(err);
          else resolve(row);
        }
      );
    });

    if (existingSubmission) {
      return res.status(400).json({ 
        message: 'You have already submitted a proof' 
      });
    }

    await new Promise((resolve, reject) => {
      db.run(
        'INSERT INTO submissions (wallet_address, name, proof_link) VALUES (?, ?, ?)',
        [walletAddress, name, proofLink],
        function(err) {
          if (err) reject(err);
          else resolve(this.lastID);
        }
      );
    });

    res.status(201).json({ 
      message: 'Submission received successfully',
      walletAddress 
    });
  } catch (error) {
    console.error('Error saving submission:', error);
    res.status(500).json({ 
      message: 'Failed to save submission' 
    });
  }
});

app.get('/api/submissions/:walletAddress', async (req, res) => {
  const { walletAddress } = req.params;

  try {
    const submission = await new Promise((resolve, reject) => {
      db.get(
        'SELECT * FROM submissions WHERE wallet_address = ?',
        [walletAddress],
        (err, row) => {
          if (err) reject(err);
          else resolve(row);
        }
      );
    });

    if (!submission) {
      return res.status(404).json({ 
        message: 'No submission found' 
      });
    }

    res.json({
      submitted: true,
      approved: submission.approved === 1,
      claimed: submission.claimed === 1,
      submittedAt: submission.submitted_at,
      approvedAt: submission.approved_at,
      claimedAt: submission.claimed_at,
      transactionHash: submission.transaction_hash,
      name: submission.name,
      proofLink: submission.proof_link
    });
  } catch (error) {
    console.error('Error fetching submission:', error);
    res.status(500).json({ 
      message: 'Failed to fetch submission' 
    });
  }
});

app.get('/api/submissions', async (req, res) => {
  try {
    const submissions = await new Promise((resolve, reject) => {
      db.all(
        'SELECT * FROM submissions ORDER BY submitted_at DESC',
        (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        }
      );
    });

    res.json(submissions.map(sub => ({
      id: sub.id,
      walletAddress: sub.wallet_address,
      name: sub.name,
      proofLink: sub.proof_link,
      submitted: true,
      approved: sub.approved === 1,
      submittedAt: sub.submitted_at,
      approvedAt: sub.approved_at,
      moderatorNotes: sub.moderator_notes
    })));
  } catch (error) {
    console.error('Error fetching submissions:', error);
    res.status(500).json({ 
      message: 'Failed to fetch submissions' 
    });
  }
});

app.put('/api/submissions/:walletAddress/approve', async (req, res) => {
  const { walletAddress } = req.params;
  const { approved, moderatorNotes } = req.body;
  
  const moderatorKey = req.headers['x-moderator-key'];
  
  if (moderatorKey !== process.env.MODERATOR_KEY) {
    return res.status(401).json({ 
      message: 'Unauthorized' 
    });
  }

  try {
    await new Promise((resolve, reject) => {
      db.run(
        `UPDATE submissions 
         SET approved = ?, approved_at = ?, moderator_notes = ?
         WHERE wallet_address = ?`,
        [approved ? 1 : 0, new Date().toISOString(), moderatorNotes || null, walletAddress],
        function(err) {
          if (err) reject(err);
          else resolve(this.changes);
        }
      );
    });

    res.json({ 
      message: 'Submission updated successfully',
      approved 
    });
  } catch (error) {
    console.error('Error updating submission:', error);
    res.status(500).json({ 
      message: 'Failed to update submission' 
    });
  }
});

app.get('/api/submissions/approved', async (req, res) => {
  try {
    const submissions = await new Promise((resolve, reject) => {
      db.all(
        'SELECT wallet_address, name FROM submissions WHERE approved = 1',
        (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        }
      );
    });

    res.json(submissions);
  } catch (error) {
    console.error('Error fetching approved submissions:', error);
    res.status(500).json({ 
      message: 'Failed to fetch approved submissions' 
    });
  }
});

// NEW: Endpoint for students to claim rewards (calls smart contract as registrar)
app.post('/api/submissions/:walletAddress/claim', async (req, res) => {
  const { walletAddress } = req.params;
  
  try {
    // Check if submission is approved in database
    const submission = await new Promise((resolve, reject) => {
      db.get(
        'SELECT * FROM submissions WHERE wallet_address = ? AND approved = 1',
        [walletAddress.toLowerCase()],
        (err, row) => {
          if (err) reject(err);
          else resolve(row);
        }
      );
    });

    if (!submission) {
      return res.status(404).json({ 
        message: 'No approved submission found for this wallet address' 
      });
    }

    // Check if already claimed
    if (submission.claimed) {
      return res.status(400).json({ 
        message: 'Reward has already been claimed' 
      });
    }

    console.log(`Processing reward claim for ${walletAddress}`);

    // Call the smart contract gradeSubmission function
    const contractResult = await gradeSubmissionOnChain(walletAddress, true);

    if (contractResult.success) {
      // Update database with transaction hash
      await new Promise((resolve, reject) => {
        db.run(
          'UPDATE submissions SET claimed = 1, claimed_at = ?, transaction_hash = ? WHERE wallet_address = ?',
          [new Date().toISOString(), contractResult.txId, walletAddress.toLowerCase()],
          function(err) {
            if (err) reject(err);
            else resolve(this.changes);
          }
        );
      });

      res.json({ 
        message: 'Reward successfully claimed! B3TR tokens have been distributed.',
        txId: contractResult.txId,
        success: true
      });
    } else {
      res.status(500).json({ 
        message: `Smart contract transaction failed: ${contractResult.error}`,
        error: contractResult.error
      });
    }

  } catch (error) {
    console.error('Error processing reward claim:', error);
    res.status(500).json({ 
      message: 'Failed to process reward claim' 
    });
  }
});

app.listen(PORT, () => {
  console.log(`Backend server running on http://localhost:${PORT}`);
});

backend/contractService.js code:
import { ThorClient } from '@vechain/sdk-network';
import pkg from '@vechain/sdk-core';
const { Address, Hex, TransactionHandler, unitsUtils, secp256k1 } = pkg;
import dotenv from 'dotenv';

dotenv.config();

// Contract configuration
const CONTRACT_ADDRESS = '0xa56903cf66bacca8fb5911eb759a8566bda978ac';
const NETWORK_URL = 'https://testnet.vechain.org/';
const REGISTRAR_PRIVATE_KEY = process.env.VECHAIN_PRIVATE_KEY;

// Contract ABI for gradeSubmission function
const GRADE_SUBMISSION_ABI = {
  name: 'gradeSubmission',
  type: 'function',
  inputs: [
    { name: 'studentAddress', type: 'address' },
    { name: 'approved', type: 'bool' }
  ],
  outputs: [],
  stateMutability: 'nonpayable'
};

// Initialize VeChain SDK
const thor = ThorClient.fromUrl(NETWORK_URL);

export async function gradeSubmissionOnChain(studentAddress, approved) {
  try {
    console.log(`Calling gradeSubmission for ${studentAddress}, approved: ${approved}`);

    // Create private key buffer
    const privateKeyBuffer = Hex.of(REGISTRAR_PRIVATE_KEY).bytes;
    
    // Derive the registrar address
    const registrarAddress = Address.ofPublicKey(secp256k1.derivePublicKey(privateKeyBuffer));
    console.log('Registrar address:', registrarAddress.toString());

    // Get the latest block
    const bestBlock = await thor.blocks.getBestBlockCompressed();
    
    // Create transaction clause
    const clause = {
      to: CONTRACT_ADDRESS,
      value: '0x0',
      data: thor.contracts.encodeFunctionInput(GRADE_SUBMISSION_ABI, [studentAddress, approved])
    };

    console.log('Transaction clause:', clause);

    // Build transaction
    const txBody = {
      chainTag: bestBlock.id.slice(-2),
      blockRef: bestBlock.id.slice(0, 18),
      expiration: 32,
      clauses: [clause],
      gasPriceCoef: 0,
      gas: 200000,
      dependsOn: null,
      nonce: Date.now().toString()
    };

    console.log('Transaction body:', txBody);

    // Sign and send transaction
    const signedTx = TransactionHandler.sign(txBody, privateKeyBuffer);
    const txId = await thor.transactions.sendTransaction(signedTx);
    
    console.log('Transaction sent:', txId);
    
    // Wait for transaction receipt
    const receipt = await waitForTransaction(txId);
    
    if (receipt && !receipt.reverted) {
      console.log('Transaction successful:', txId);
      return {
        success: true,
        txId: txId,
        receipt: receipt
      };
    } else {
      console.error('Transaction reverted:', receipt);
      return {
        success: false,
        txId: txId,
        error: 'Transaction was reverted'
      };
    }

  } catch (error) {
    console.error('Error calling gradeSubmission:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

async function waitForTransaction(txId, timeout = 30000) {
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeout) {
    try {
      const receipt = await thor.transactions.getTransactionReceipt(txId);
      if (receipt) {
        return receipt;
      }
    } catch (error) {
      // Transaction not found yet, continue waiting
    }
    
    // Wait 2 seconds before checking again
    await new Promise(resolve => setTimeout(resolve, 2000));
  }
  
  throw new Error('Transaction timeout');
}

and this is contract code:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// Interface for VeBetterDAO X2EarnRewardsPool
interface IX2EarnRewardsPool {
    function distributeReward(
        bytes32 appId,
        uint256 amount,
        address receiver,
        string memory proof
    ) external;
    
    function availableFunds(bytes32 appId) external view returns (uint256);
}

contract Learn2Earn {

    // The address of the registrar (contract creator)
    address private registrar;

    // The name of the university
    string public institute;
    
    // VeBetterDAO integration
    IX2EarnRewardsPool public x2EarnRewardsPoolContract;
    bytes32 public appId;
    uint256 public rewardAmount = 10 * 10**18; // 10 B3TR tokens per approved submission

    // Structure to store student information
    struct Student {
        address wallet;         // Student's wallet address
        string name;            // First name
        string familyName;      // Last name
        bool registered;        // True if student is registered
        bool graduated;         // True if student has graduated
        bytes32 certificate;    // Certificate hash (created when student graduates)
    }

    // Mapping from wallet address to student data
    mapping(address => Student) public students;

    // NEW: Mapping to store proof submissions
    mapping(address => string) public submissions;
    
    // NEW: Mapping to track if submission has been graded
    mapping(address => bool) public graded;
    
    // NEW: Mapping to track if student has been rewarded
    mapping(address => bool) public rewarded;

    // Event triggered when a certificate is issued
    event CertificateIssued(string institute, bytes32 certificateHash, address student);
    
    // NEW: Event triggered when a proof is submitted
    event SubmissionReceived(address indexed user, string proof);
    
    // NEW: Event triggered when a submission is graded and approved
    event SubmissionGraded(address indexed user, bool approved);
    
    // NEW: Event triggered when rewards are distributed
    event RewardDistributed(address indexed user, uint256 amount);

    // Set the university name, registrar, and VeBetterDAO details when contract is deployed
    constructor(
        string memory _institute,
        address _x2EarnRewardsPoolContract,
        bytes32 _appId
    ) {
        registrar = msg.sender;
        institute = _institute;
        x2EarnRewardsPoolContract = IX2EarnRewardsPool(_x2EarnRewardsPoolContract);
        appId = _appId;
    }

    // Function for students to register by paying 1 VET
    function addStudent(string memory _name, string memory _familyName) public payable {
        require(msg.value == 1 ether, "You must pay 1 VET to register.");

        // Make sure the student isn't already registered
        require(!students[msg.sender].registered, "You are already registered.");

        // Create a new student record
        students[msg.sender] = Student({
            wallet: msg.sender,
            name: _name,
            familyName: _familyName,
            registered: true,
            graduated: false,
            certificate: 0
        });
    }

    function _checkStudent(address studentAddress) view private returns (bool){
        Student storage student = students[studentAddress];
        require(student.registered, "This person is not a registered student.");
        return true;
    }

    // NEW: Function for students to submit proof of learning completion
    function submitProof(string memory proof) public {
        require(students[msg.sender].registered, "You must be a registered student to submit proof.");
        require(!students[msg.sender].graduated, "You have already graduated.");
        require(bytes(proof).length > 0, "Proof cannot be empty.");
        
        // Store the submission
        submissions[msg.sender] = proof;
        
        // Emit event
        emit SubmissionReceived(msg.sender, proof);
    }

    // NEW: Function for registrar to grade submissions and trigger rewards
    function gradeSubmission(address studentAddress, bool approved) public {
        require(msg.sender == registrar, "Only the registrar can grade submissions.");
        require(students[studentAddress].registered, "This person is not a registered student.");
        require(bytes(submissions[studentAddress]).length > 0, "No submission found for this student.");
        require(!graded[studentAddress], "This submission has already been graded.");
        
        // Mark as graded
        graded[studentAddress] = true;
        
        // Emit grading event
        emit SubmissionGraded(studentAddress, approved);
        
        if (approved && !rewarded[studentAddress]) {
            // Distribute VeBetterDAO rewards
            _distributeReward(studentAddress);
        }
    }
    
    // NEW: Internal function to distribute VeBetterDAO rewards
    function _distributeReward(address studentAddress) private {
        require(rewardAmount > 0, "Reward amount must be greater than 0");
        require(
            rewardAmount <= x2EarnRewardsPoolContract.availableFunds(appId),
            "Insufficient funds in rewards pool"
        );
        
        // Mark as rewarded to prevent double rewards
        rewarded[studentAddress] = true;
        
        // Create proof string with submission info
        string memory proof = string(abi.encodePacked(
            '{"type":"education","submission":"',
            submissions[studentAddress],
            '","institute":"',
            institute,
            '"}'
        ));
        
        // Call VeBetterDAO to distribute rewards
        x2EarnRewardsPoolContract.distributeReward(
            appId,
            rewardAmount,
            studentAddress,
            proof
        );
        
        emit RewardDistributed(studentAddress, rewardAmount);
    }

    // Registrar can mark a student as graduated (after grading)
    function issueCertificate(address studentAddress) public {
        require(msg.sender == registrar, "Only the registrar can issue certificates.");

        if (_checkStudent(studentAddress)){
            Student storage student = students[studentAddress];
            require(!student.graduated, "This student has already graduated.");
            
            // NEW: Ensure submission was graded and approved before issuing certificate
            require(graded[studentAddress], "Student submission must be graded first.");
            
            // Create a certificate and mark as graduated
            student.certificate = keccak256(abi.encodePacked(block.timestamp, student.wallet));
            student.graduated = true;

            // Emit event
            emit CertificateIssued(institute, student.certificate, student.wallet);
        }
    }

    // Check if a student has graduated
    function isGraduated(address studentAddress) public view returns (bool) {
        return students[studentAddress].graduated;
    }
    
    // NEW: Get a student's submission
    function getSubmission(address studentAddress) public view returns (string memory) {
        return submissions[studentAddress];
    }
    
    // NEW: Check if a submission has been graded
    function isGraded(address studentAddress) public view returns (bool) {
        return graded[studentAddress];
    }
    
    // NEW: Check if a student has been rewarded
    function isRewarded(address studentAddress) public view returns (bool) {
        return rewarded[studentAddress];
    }
    
    // NEW: Get available funds in the rewards pool
    function getAvailableFunds() public view returns (uint256) {
        return x2EarnRewardsPoolContract.availableFunds(appId);
    }
    
    // NEW: Registrar can set reward amount
    function setRewardAmount(uint256 _amount) public {
        require(msg.sender == registrar, "Only the registrar can set reward amount.");
        require(_amount > 0, "Amount must be greater than 0.");
        rewardAmount = _amount;
    }
    
    // NEW: Registrar can update app ID
    function updateAppId(bytes32 _appId) public {
        require(msg.sender == registrar, "Only the registrar can update app ID.");
        appId = _appId;
    }
    
    // NEW: Registrar can withdraw collected VET from student registrations
    function withdrawBalance() public {
        require(msg.sender == registrar, "Only the registrar can withdraw.");
        uint256 balance = address(this).balance;
        require(balance > 0, "No balance to withdraw.");
        (bool success, ) = payable(registrar).call{value: balance}("");
        require(success, "Transfer failed.");
    }
}

and these .env.example for repo:
# Backend Configuration
PORT=3001
MODERATOR_KEY=your-secret-moderator-key-here

# Frontend Configuration
REACT_APP_API_URL=http://localhost:3001/api

# VeChain Contract Configuration
REACT_APP_CONTRACT_ADDRESS=0x0000000000000000000000000000000000000000
REACT_APP_NETWORK=testnet

# WalletConnect Project ID
REACT_APP_WALLET_CONNECT_PROJECT_ID=your-wallet-connect-project-id

# Deployment Configuration
VECHAIN_PRIVATE_KEY=your-private-key-here

# VeBetterDAO Testnet Addresses (DO NOT MODIFY)
X2EARN_REWARDS_POOL=0x5F8f86B8D0Fa93cdaE20936d150175dF0205fB38
X2EARN_APPS=0xcB23Eb1bBD5c07553795b9538b1061D0f4ABA153
B3TR_TOKEN=0xbf64cf86894Ee0877C4e7d03936e35Ee8D8b864F
B3TR_FAUCET=0x5e9c1F0f52aC6b5004122059053b00017EAfB561

# Your VeBetterDAO App ID (obtain after registration)
VEBETTERDAO_APP_ID=0x0000000000000000000000000000000000000000000000000000000000000001

now based on this check what we aremissing and not doinn that connects our deployed cntract to smart contracta nd we can preform on chain transaction on vechain tes5ent. I wanwt the contarct t wrk with frontend through veworld wallet. you do anyting for that. just deep dive and fix thisasap now.